%!PS-Adobe-3.0
%%Title: (10.SAP-2)
%%Creator: (FrameMaker5: LaserWriter 8 8.7)
%%CreationDate: (10:11 AM Wednesday, July 11, 2001)
%%For: (David Gerhard)
%%Routing: (mailto:\000dbg@canada.com)
%%Pages: 8
%%DocumentFonts: Times-Roman Times-Bold Helvetica-Bold Symbol
%%DocumentNeededFonts: Times-Roman Times-Bold Helvetica-Bold Symbol
%%DocumentSuppliedFonts: 
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%%DocumentMedia: (Default) 612 792 0 () ()
%RBINumCopies: 1
%RBINupNess: 1 1
%ADO_ImageableArea: 30 33 582 761
%RBIDocumentSuppliedFonts: 
%%EndComments
%%BeginDefaults
%%ViewingOrientation: 1 0 0 1
%%EndDefaults
userdict/dscInfo 5 dict dup begin
/Title(10.SAP-2)def
/Creator(FrameMaker5: LaserWriter 8 8.7)def
/CreationDate(10:11 AM Wednesday, July 11, 2001)def
/For(David Gerhard)def
/Pages 8 def
end put
%%BeginProlog
/md 212 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: lw8_feature-1.01
%%Copyright: Copyright 1990-1999 Adobe Systems Incorporated and Apple Computer Incorporated. All Rights Reserved.
/bd{bind def}bind def
/ld{load def}bd
/xs{exch store}bd
/Z{0 def}bd
/T true def
/F false def
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
F
}ifelse
def
/odictstk Z
/oopstk Z
/fcl
{
count oopstk sub dup 0 gt
{
{pop}repeat
}{
pop
}ifelse
countdictstack odictstk sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/sfcl2
{
/odictstk countdictstack store
count/oopstk xs
}bd
/efcl2
{
stopped{$error/newerror F put}if
fcl
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
/setcopies{
level2
{
1 dict begin/NumCopies exch def currentdict end setpagedevice
}{
userdict/#copies 3 -1 roll put
}ifelse
}def
level2 startnoload
/ststpgdev{}def
/dopgdev{}def
/stpgdev{}def
/buf Z
/didstop T def
/sfcl
{
/didstop T store
/odictstk countdictstack store
count/oopstk xs
currentfile cvx stopped
{
$error/newerror F put
didstop
{
save/didstop xs
/buf vmstatus exch sub exch pop dup 0 lt{pop 0}if
dup 64000 gt{pop 64000}if string store
{
currentfile buf readline
{
(}efcl)eq{exit}if
}{
/UnexpectedEOF errordict/rangecheck get exec
}ifelse
}loop
didstop restore
}if
}if
fcl
}bd
/efcl
{
/didstop F store
exec
stop
}bd
level2 endnoload level2 not startnoload
/setpagedevice where{pop/realstpgdev/setpagedevice ld}if
/SC_topddict Z
/SC_spdict Z
/$spusrdict F def
/dopgdev
{
userdict/setpagedevice undef
$spusrdict
{
userdict/setpagedevice/realstpgdev load put
/$spusrdict F store
}if
SC_topddict realstpgdev
}bd
/stpgdev
{
SC_topddict dup 3 -1 roll
{
SC_spdict 2 index known
{
SC_spdict 2 index get
dup 3 -1 roll
{
put dup
}forall
pop put dup
}{
put dup
}ifelse
}forall
pop pop
}bd
/ststpgdev
{
/setpagedevice where
{
userdict eq
{
/$spusrdict T store
}if
}if
userdict/setpagedevice/stpgdev load put
/SC_topddict 0 dict store
/SC_spdict 3 dict begin
/InputAttributes 0 dict def
/Policies 0 dict def
/OutputAttributes 0 dict def
currentdict
end
store
}def
/sfcl/sfcl2 ld
/efcl/efcl2 ld
level2 not endnoload
%%EndFile
%%BeginFile: lw8_basic-4.0
/xdf{exch def}bd
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
12{ld}repeat
/framewidth -1 def
/QDframwid -1 def
/numframes Z
/mTS matrix def
/$m matrix def
/av 87 def
/por T def
/normland F def
/psb-nosave{}def
/pse-nosave{}def
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level3
/languagelevel where
{
pop languagelevel 3 ge
}{
F
}ifelse
def
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/devg/DeviceGray def
/devr/DeviceRGB def
/devc/DeviceCMYK def
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/devg[/DeviceGray]def
/devr[/DeviceRGB]def
/devc[/DeviceCMYK]def
level2 not endnoload
/pm Z
/mT Z
/sD Z
/mTSsetup{
mT $m currentmatrix mTS concatmatrix pop
}bd
/pmSVsetup{
/pm save store
}bd
/initializepage
{
mT concat
}bd
/endp
{
pm restore
}bd
/adjRect
{
dup 2 mul 6 2 roll
4 index sub exch 5 -1 roll sub exch
4 2 roll
4 index add exch 5 -1 roll add exch
4 2 roll
}bd
/frame1up
{
gS
mTS setmatrix
QDframwid lw
/setstrokeadjust where{pop T setstrokeadjust}if
clippath pathbbox
2 index sub exch
3 index sub exch
currentlinewidth framewidth mul
adjRect
numframes dup 0 lt{pop 0}if
{
4 copy
rS
currentlinewidth framewidth
mul 4 mul
adjRect
}repeat
pop pop pop pop
gR
}bd
/$c devr def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
level3 startnoload
%%BeginFile: lw8_safeclipL12-1.0
/rectclip where
{
pop/rCa/rectclip ld
}{
/rCa
{
np 0
1 index length 4 idiv
{
2 copy
4 getinterval
aload pop
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
4 add
}repeat
clip np
pop pop
}bd
}ifelse
/savedstack Z
/subsavedstack Z
/execstring Z
/saferCa
{
/execstring xs
/odictstk countdictstack store
/oopstk 0 store
count 0 ne
{
savedstack 0 eq{
count 100 gt{count}{100}ifelse
array/savedstack xs
}{
count savedstack length gt
{
count array/savedstack xs
}if
}ifelse
count savedstack 0 3 -1 roll
getinterval
astore/subsavedstack xs
}{
/subsavedstack 0 store
}ifelse
execstring cvx stopped
{
$error/newerror F put
newpath
}if
fcl
subsavedstack 0 ne{
subsavedstack aload pop
}if
}bd
%%EndFile
level3 endnoload level3 not startnoload
%%BeginFile: lw8_safeclipL3-1.0
/saferCa/pop ld
%%EndFile
level3 not endnoload
%%BeginFile: lw8_level1_colorspace-2.0
/G/setgray ld
/:F1/setgray ld
/:F/setrgbcolor ld
/:F4/setcmykcolor where
{
pop
/setcmykcolor ld
}{
{
3
{
dup
3 -1 roll add
dup 1 gt{pop 1}if
1 exch sub
4 1 roll
}repeat
pop
setrgbcolor
}bd
}ifelse
/:Fx
{
counttomark
{0{G}0{:F}{:F4}}
exch get
exec
pop
}bd
/$cs Z
/:rg{devr :ss}bd
/:sc{$cs :ss}bd
/:dc
{
dup type/arraytype eq{0 get}if
dup/DeviceCMYK eq
{
pop devc
}{
/DeviceGray eq
{
devg
}{
devr
}ifelse
}ifelse
/$cs xdf
}bd
/:sgl{}def
/:dr{}bd
/:fCRD{pop}bd
/:ckcs{}bd
/:ss{/$c xdf}bd
%%EndFile
%%BeginFile: lw8_bubn-2.1
/$t Z
/$p Z
/$s Z
/$o 1. def
/2state? F def
/ps Z
level2 startnoload
/pushcolor/currentrgbcolor ld
/popcolor/setrgbcolor ld
/setcmykcolor where
{
pop/currentcmykcolor where
{
pop/pushcolor/currentcmykcolor ld
/popcolor/setcmykcolor ld
}if
}if
level2 endnoload level2 not startnoload
/pushcolor
{
currentcolorspace $c eq
{
currentcolor currentcolorspace T
}{
currentcmykcolor F
}ifelse
}bd
/popcolor
{
{
setcolorspace setcolor
}{
setcmykcolor
}ifelse
}bd
level2 not endnoload
/pushstatic
{
2state?
$o
$t
$p
$s
$cs
ps
}bd
/popstatic
{
/ps xs
/$cs xs
/$s xs
/$p xs
/$t xs
/$o xs
/2state? xs
}bd
/pushgstate
{
currentpoint
pushcolor
currentlinewidth
currentlinecap
currentlinejoin
currentdash exch aload length
np clippath pathbbox
$m currentmatrix aload pop
}bd
/popgstate
{
$m astore setmatrix
2 index sub exch
3 index sub exch
rC
array astore exch setdash
setlinejoin
setlinecap
lw
popcolor
np :M
}bd
/bu
{
errordict/nocurrentpoint{pop 0 0}put
2state?
{
pushgstate
gR
}if
pushgstate
gR
pushgstate
pushstatic
pm restore
mTS setmatrix
}bd
/bn
{
/pm save store
popstatic
popgstate
gS
popgstate
2state?
{
gS
popgstate
}if
}bd
/cpat{pop 64 div setgray 8{pop}repeat}bd
%%EndFile
%%BeginFile: lw8_basic_text-3.0
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg T def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg F store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/$o 1. def
/gl{$o G}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding dup 9/space put dup 39/quotesingle put 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/Euro/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
/$ckeyd md def
/:skey
{
1 index maxlength 2 index
length sub
ge
{
begin
/$mkeys 20 dict def
/$mkeys load
end
dup/$ckeyd xs
}if
3 1 roll put
}bd
/fD1pass
{
40
$ckeyd
//md
ne
{
pop 1
}if
$ckeyd exch
:skey
}bd
/:searchdict Z
/:searchdict
{
exch 2 copy
known
{
get
}{
exch/$mkeys
get
:searchdict
}ifelse
}bd
/lU
{
//md exch 2 copy
known
{
get
}{
exch
/$mkeys get
:searchdict
}ifelse
}bd
/:xs{
exch 0 1 2 index length 1 sub{
3 copy
gS 1 getinterval show gR
exch
get 0.0
rm
}for pop pop
}bd
/:ys{
exch 0 1 2 index length 1 sub{
3 copy
gS 1 getinterval show gR
exch
get 0.0 exch
rm
}for pop pop
}bd
/:xys{
exch 0 1 2 index length 1 sub{
3 copy
gS 1 getinterval show gR
exch 2 mul 2 copy
1 add get 3 -2 roll get exch
rm
}for pop pop
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
/fD1pass/def ld
/lU/load ld
level2{
/:xs/xshow ld
/:ys/yshow ld
/:xys/xyshow ld
}if
level2 not endnoload
/:xbl{
currentpoint
2 index exec
:M
.03 ps mul currentpoint
2 index 0.0
rm
3 index
exec
:M currentpoint
2 index dup
rm
3 index exec
:M
0.0 1 index
rm exch
exec
neg 0.0 exch
rm
}bd
/:xot{
currentpoint -2.0 0.0 rm 2 index exec :M
currentpoint 0.0 -2.0 rm 2 index exec :M
currentpoint 0.0 2.0 rm 2 index exec :M
currentpoint 2.0 0.0 rm 2 index exec :M
gS gl exec currentpoint gR :M
}bd
/:xsh{
2 ps 0.05 mul add
2 copy
currentpoint
5 2 roll
0.0 rm
exec
currentpoint
6 2 roll
sub moveto
:xot
moveto
}bd
/fD Z
/sf Z
/scf Z
/sf1pass
{
lU setfont
}bd
/scf1pass
{
exch lU exch scalefont fD
}bd
/scf2pass
{
scalefont fD
}bd
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff fD
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff fD
}bd
/ps Z
/fz{/ps xs}bd
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
fD
}def
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if end
%%EndProlog
%%BeginSetup
md begin
/fD/def ld/sf/setfont ld /scf/scf2pass ld
%RBIIncludeNonPPDFeature: NumCopies 1
%RBIBeginNonPPDFeature: WaitTimeout 600
 600/languagelevel where{pop languagelevel 2 ge}{false}ifelse{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%RBIEndNonPPDFeature
sfcl{
%%BeginFeature: *InputSlot Upper

%%EndFeature

}efcl

sfcl{
%%BeginFeature: *ManualFeed False
level2 {1 dict dup /ManualFeed false put setpagedevice}{statusdict begin /manualfeed false store end} ifelse
%%EndFeature

}efcl

sfcl{
%%BeginFeature: *PageRegion Letter
level2 { 
		2 dict dup /PageSize [612 792] put dup /ImagingBBox null put setpagedevice
	}{
		/letter where {pop letter}{letterR} ifelse
	} ifelse
%%EndFeature

}efcl

(David Gerhard)setjob
/mT[1 0 0 -1 30 761]def
%RBIIncludeStartNup
/sD 16 dict def
%%IncludeFont: Times-Roman
/f133/Times-Roman
:mre
/f148 f133 12 scf
%%IncludeFont: Times-Bold
/f161/Times-Bold
:mre
/f175 f161 18 scf
/f188 f161 16 scf
/f201 f161 12 scf
%%IncludeFont: Helvetica-Bold
/f224/Helvetica-Bold
:mre
/f240 f224 12 scf
%%IncludeFont: Symbol
/f262/Symbol
%%BeginFile: lw8_euroSpecial-1.01
/nEro
/Symbol findfont
begin
FontType
dup dup dup dup
1 eq exch 5 eq or exch 42 eq or exch 43 eq or exch 3 eq or{
currentdict/CharStrings known{
CharStrings/Euro known
}{
true
}ifelse
}{
true
}ifelse
end
def
nEro startnoload
10 dict begin
/FontInfo 2 dict dup begin
/version(001.000)def
/Notice(Copyright \251 1998 Apple Computer Inc.)def
end def
/FontName/Europatch def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix[0.001 0 0 0.001 0 0]def
/FontBBox{21 -9 714 689}def
currentdict end
dup
/Private 15 dict dup begin
/|-{def}def
/|{put}def
/BlueValues[-19. 0. 487. 500. 673. 688.]|-
/BlueScale 0.0526315789 def
/MinFeature{16 16}|-
/StdHW[92.]def
/StdVW[85.]def
/StemSnapH[92.]def
/StemSnapV[85.]def
/ForceBoldThreshold .5 def
/ForceBold false def
/password 5839 def
/Subrs 16 array
dup 0<118cade7978c9a8ab47e7be71fa277>|
dup 1<118cade79273658a5c>|
dup 2<118cade7927297416d>|
dup 3<118cade712>|
dup 4<118cade795e45b7819d5b190>|
dup 5<118cade712>|
dup 6<118cade712>|
dup 7<118cade79266e29ec4a224>|
dup 8<118cade7926513197e6246425e>|
dup 9<118cade792645d0ab32061e2268dfb>|
dup 10<118cade792638e135e25d183266bd7f81e>|
dup 11<118cade7927439b1>|
dup 12<118cade7e644d1e7a50cacbc>|
dup 13<118cade78f9ed1e3fe>|
dup 14<118cade7e0d1ca3c54>|
dup 15<118cade78f9edf3959>|
|-
2 index
/CharStrings 2 dict dup begin
/A<118cade7b98bc82571af5aee01f90103a394bff91b0ba5c07ffa5d64ff811d8a387b6ec3142
e3c549269606becee2076d12186aced6d3558a7713c6635c038cf4bf8afc6076160e8ead2af885
9f19c117df2af5a56fd0c316f31ba13c15c7ce3110f9d01081b9aeb32fbe8a3618047f1e92e6e0
8818a4bb109a567da3f88883d9eb237a4257a9535d72a66345d6a36508b96c2805a310781de324
fe691942dd7947ac02673d33943c06ae133ef93a7292b6dab>|-
/.notdef<118cade79205cabfe7>|-
end end
put put
dup/FontName get exch definefont pop
nEro endnoload
/subfontdict Z
/subfontcharsize Z
findfont dup
length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and
{def}{pop pop}ifelse
}forall
nEro not
{
/subfontdict
[
/Europatch findfont FontMatrix
matrix invertmatrix makefont
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth 12 def
/customfont currentdict
end
definefont
]def
gsave
initgraphics
/subfontcharsize[
subfontdict 0 get setfont(A)stringwidth
0 0 moveto(A)true charpath
pathbbox
]def
grestore
/CharStrings CharStrings
dup length 1 add dict
level2
{
copy
}{
begin
{
def
}forall
currentdict
end
}ifelse
dup
/Euro{
subfontcharsize aload pop
setcachedevice
pop
subfontdict currentdict/PaintType get
dup 0 ne{pop 1}if
get setfont
0 0 moveto
(A)show
}bind put
def
}if
/Encoding Encoding 256 array copy
dup 240/apple pd
160/Euro put
def
fontname/customfont eq
{
/Symbol
}{
fontname
}ifelse
currentdict
end
definefont :ff fD
%%EndFile
/f274 f262 12 scf
/f287 f262 11 scf
/f300 f133 11 scf
{/Courier findfont[10 0 0 -10 0 0]:mf setfont}stopped{$error/newerror F put}if
% Frame PostScript Prolog for use with Macintosh Frame Products 5.x.x
% Copyright (c) 1986-96 Adobe Systems Inc.  All rights reserved.
%%BeginProcSet: "FrameMacDict" 501 1
userdict/FrameMacDict 250 dict put FrameMacDict begin systemdict/setpacking
known{/fMSP currentpacking def true setpacking}if[/fM1/fM18/fM2/fM3/fM4/fMAB
/fM5/fM6/fM8/fM9/fMBC/fMBM/fMC/fMCD/fMCG/fMCK/fMCM/fMCl/fMCO/fMef/fMet/fMeh
/fMew/fMey/fMex/fMei/fMej/fMek/fMel/fMFl/fMGC/fMGL/fMGM/fMIx/fMJB/fMJC/fMJG
/fMJK/fMJM/fMJR/fMJY/fMK/fML1/fMM/fMN/fMNC/fMNg/fMND/fMOx/fMPC/fMPH/fMPt/fMRC
/fMS/fMSJ/fMUC/fMUM/fMUY/fMY/fMdm/fM2x/fMa2/fMi/fMk/fms/fmBS/fMdp/freq/sangle
/sflipx/sflipy/pflipx/pflipy/xx/yy/xindex/yindex/fM1B/fM0B/fMdc/fMds]{0 def}
forall/fML1/languagelevel where{pop languagelevel}{1}ifelse 2 lt def/fMCl fML1{
/statusdict where{pop statusdict/processcolors known{statusdict/processcolors
get exec 1 gt}{F}ifelse}{F}ifelse}{T}ifelse def/fMXN/statusdict where{pop
statusdict/product known{statusdict/product get}{(Unknown)}ifelse}{(Unknown)}
ifelse def/fMHq fMXN(LaserWriter-Sim)eq def/FmBD{bind def}bind def/fmBx{[exch{
dup/FrameMacDict eq{pop FrameMacDict}{dup type dup/arraytype eq exch
/packedarraytype eq or{dup xcheck{fmBi}if}if}ifelse}forall]cvx}FmBD/fmBi{bind
fmBx}FmBD fML1{userdict/FrMacBegin{FrameMacDict begin}fmBi put/FmE{end}FmBD}{
/fMdc 6 array def userdict/FrMacBegin{FrameMacDict begin/fMds currentcolorspace
store mark 0 0 0 0 0 currentcolor fMdc astore pop cleartomark}fmBi put/FmE{fMds
setcolorspace mark fMdc aload pop setcolor cleartomark end}FmBD}ifelse/fMEd 35
dict def/fmPE{fMEd 3 1 roll fmBi put}bind def/T true def/F false def userdict
/FrameSuccessfull F put userdict/FrameEndPictSave F put userdict
/FrameEndPictStopped F put userdict/fM7 known not{userdict/fM7 0 put}if/fmXD{
exch def}FmBD/FmG/gsave load def/FmR/grestore load def/fm_l/grestoreall load
def/fm_v/save load def/fm_g/setgray load def/fm_r/setrgbcolor load def/fm_h
/sethsbcolor load def/fm_f/fill load def/fm_e/eofill load def/fm_t/stroke load
def/fm_m/imagemask load def/fm_i/image load def/fm_s/show load def/fm_a/ashow
load def/fm_w/widthshow load def/fm_y/awidthshow load def/RealKshow/kshow load
def/fMdm matrix defaultmatrix def/fM2x matrix def/fMa2 matrix def/fmSM{fM2x
currentmatrix pop}FmBD/fmRM{fM2x setmatrix}FmBD/FmRF{currentpoint 2 copy
translate 4 2 roll{-1 1 scale}if rotate neg exch neg exch translate}FmBD/fmax{2
copy lt{exch}if pop}FmBD/fmin{2 copy gt{exch}if pop}FmBD systemdict/pdfmark
known{/fMAB true def/FmPD/pdfmark load def/FmPT/fm_s load def
currentdistillerparams/CoreDistVersion get 2000 ge{/FmPD2/pdfmark load def/FmPA
{mark exch/Dest exch 5 3 roll/View[/XYZ null 6 -2 roll FmDC exch pop null]/DEST
FmPD}FmBD}{/FmPD2/cleartomark load def/FmPA{pop pop pop}FmBD}ifelse}{/fMAB
false def/FmPD/cleartomark load def/FmPD2/cleartomark load def/FmPT/pop load
def/FmPA{pop pop pop}FmBD}ifelse/FmDC{transform fMdm itransform cvi exch cvi
exch}FmBD/FmBx{dup 3 index lt{3 1 roll exch}if 1 index 4 index lt{4 -1 roll 3 1
roll exch 4 1 roll}if}FmBD/fmgS 32 array def/fMgt 0 def/fMtp 0 def/fmSG{fmgS
fMgt get dup null eq{pop fmgS fMgt 10 dict dup 4 1 roll put}if 3 1 roll put}
FmBD/fmGG{fMgt -1 -1{fmgS exch get dup null ne{2 copy exch known{2 copy exch
get/_notdef ne{exch get dup exit}if}if}if pop}for pop}FmBD/gsave{FrameMacDict
begin FmG/fMgt fMgt 1 add def fmgS fMgt get dup null eq{pop}{dup dup{pop
/_notdef put dup}forall pop pop}ifelse end}fmPE/grestore{FrameMacDict begin
fMgt fMtp gt{/fMgt fMgt 1 sub def}if FmR null fmCN end}fmPE/grestoreall{
FrameMacDict begin/fMgt fMtp def fm_l null fmCN end}fmPE/save{FrameMacDict/fm_v
get exec FrameMacDict begin/fMgt fMgt 1 add def fmgS fMgt get dup null eq{pop}{
dup dup{pop/_notdef put dup}forall pop pop}ifelse/fMtp fMgt def end}fmPE/fMND F
def/fMCC null fmSG/fMOP F fmSG/fMKO F fmSG/fmRY{1 exch sub 3 1 roll 1 exch sub
3 1 roll 1 exch sub 3 1 roll 3 copy 2 copy le{pop}{exch pop}ifelse 2 copy le{
pop}{exch pop}ifelse dup dup dup 6 1 roll 4 1 roll 7 1 roll sub 6 1 roll sub 5
1 roll sub 4 1 roll}fmSG/fmkn{2 copy known{get T}{pop pop false}ifelse}FmBD
/fmfp{exch currentfont dup/FontMatrix get exch/FontInfo fmkn{T}{currentfont/df
fmkn{dup/FontInfo fmkn{3 1 roll/FontMatrix get mtx concatmatrix exch T}{pop pop
pop F}ifelse}{pop pop F}ifelse}ifelse{3 -1 roll fmkn{exch 0 3 1 roll dtransform
neg exch pop exch pop}{pop exec}ifelse}{exec}ifelse}FmBD/fmdl{3 index 16 and 0
ne{FmG currentlinewidth 2. div dup rmoveto currentpoint newpath moveto 2 index
0 rlineto fm_t FmR}if 3 index 24 and 0 ne{FmG currentrgbcolor dup 4 1 roll eq 3
1 roll eq and{1 currentgray sub setgray}{1 setgray}ifelse 2 index 0 rlineto
fm_t FmR FmG 2 index 0 rlineto strokepath .24 setlinewidth fm_t FmR}{2 index 0
rlineto fm_t 0 0 moveto}ifelse}FmBD/FmUl{FmG/fM2 fmXD currentpoint
/UnderlineThickness{fM2 15 div}fmfp abs dup setlinewidth/fM1 fmXD 4 index 1 and
0 ne{newpath 2 copy moveto 0/UnderlinePosition{fM2 10 div neg}fmfp neg rmoveto
fmdl}if 4 index 2 and 0 ne{newpath 2 copy moveto 0/XHeight{FmG newpath 0 0
moveto(x)F charpath flattenpath pathbbox 4 -1 roll pop pop pop FmR dup 0 eq{pop
fM2 2. mul 3. div neg}if}fmfp 2. div rmoveto fmdl}if 4 index 4 and 0 ne{newpath
2 copy moveto 0/CapHeight{FmG newpath 0 0 moveto(H)F charpath flattenpath
pathbbox 4 -1 roll pop pop pop FmR dup 0 eq{pop fM2 3. mul 4. div neg}if}fmfp
fM1 sub rmoveto fmdl}if pop pop pop pop pop FmR}FmBD/FmTx{/fM3 fmXD/fM2 fmXD
/fM1 fmXD 0 32 fM1 fM3 stringwidth pop fM2 sub fM3 length div sub 0 fM3 fm_y}
FmBD/fMN 0 def/fMC 1 def/fMM 2 def/fMY 3 def/fMK 4 def/fMS 5 def/fMNg 0
currenttransfer exec .5 gt def/fMCM fMN def/fMJK 0 def/fMJY 0 def/fMJM 0 def
/fMJC 0 def/fMJR 1 def/fMJG 1 def/fMJB 1 def/fMCG 1 def/fMPt null def/fMCK[0 0
0 1 0 0 0]def/fmCH{fML1{14 dict dup begin fMCl{/HalftoneType 2 def
currentcolorscreen[/GraySpotFunction/GrayAngle/GrayFrequency/BlueSpotFunction
/BlueAngle/BlueFrequency/GreenSpotFunction/GreenAngle/GreenFrequency
/RedSpotFunction/RedAngle/RedFrequency]{exch def}forall}{/HalftoneType 1 def
currentscreen[/SpotFunction/Angle/Frequency]{exch def}forall}ifelse statusdict
/checkscreen known{statusdict/accuratescreens get exec}{F}ifelse
/AccurateScreens exch def end}{currenthalftone}ifelse}FmBD/fmSH{fML1{begin
statusdict/checkscreen known{currentdict/AccurateScreens known{AccurateScreens}
{F}ifelse statusdict/setaccuratescreens get exec}if HalftoneType 1 eq{Frequency
Angle currentdict/SpotFunction get setscreen}{HalftoneType 2 eq{fMCl{
RedFrequency RedAngle currentdict/RedSpotFunction get GreenFrequency GreenAngle
currentdict/GreenSpotFunction get BlueFrequency BlueAngle currentdict
/BlueSpotFunction get GrayFrequency GrayAngle currentdict/GraySpotFunction get
setcolorscreen}{GrayFrequency GrayAngle currentdict/GraySpotFunction get
setscreen}ifelse}if}ifelse end}{sethalftone}ifelse}FmBD/FmCS{14 dict begin
/HalftoneType 2 def/AccurateScreens exch def/GraySpotFunction exch def
/GrayAngle exch def/GrayFrequency exch def/BlueSpotFunction exch def/BlueAngle
exch def/BlueFrequency exch def/GreenSpotFunction exch def/GreenAngle exch def
/GreenFrequency exch def/RedSpotFunction exch def/RedAngle exch def
/RedFrequency exch def currentdict dup end/fMPH exch def fmSH}FmBD/FmSS{5 dict
begin/HalftoneType 1 def/AccurateScreens exch def/SpotFunction exch def/Angle
exch def/Frequency exch def currentdict dup end/fMPH exch def fmSH}FmBD/fMPH
fmCH def/fmcp{/FmPr2 exch cvlit def/FmPr1 exch cvlit def/FmPrn FmPr1 length
FmPr2 length add array def FmPrn 0 FmPr1 putinterval FmPrn FmPr1 length FmPr2
putinterval FmPrn cvx}FmBD/fmEp{sub dup 0 lt{neg}if .001 le}FmBD/fmQC{2 copy 0
get exch 0 get fmEp{2 copy 1 get exch 1 get fmEp{2 copy 2 get exch 2 get fmEp{3
get exch 3 get fmEp}{pop pop F}ifelse}{pop pop F}ifelse}{pop pop F}ifelse}FmBD
/fmQR{2 copy 4 get exch 0 get fmEp{2 copy 5 get exch 1 get fmEp{6 get exch 2
get fmEp}{pop pop F}ifelse}{pop pop F}ifelse}FmBD/FmSC{/fMCM fmXD/fMJB fmXD
/fMJG fmXD/fMJR fmXD/fMJK fmXD/fMJY fmXD/fMJM fmXD/fMJC fmXD fmCC}FmBD/FmSP{
/fMCM fmXD fmCC}FmBD/FrameSetSepColors{FrameMacDict begin[exch 1 add 1 roll]
/fMSC exch def end}fmBi def/fmLC{fMSC{exch dup 3 -1 roll fmQC{pop T exit}if}
forall dup T ne{pop F}if}FmBD/fmLR{fMSC{exch dup 3 -1 roll fmQR{pop T exit}if}
forall dup T ne{pop F}if}FmBD/fmLM{fMSC{exch dup 3 -1 roll dup 7 get 3 -1 roll
eq{exch pop T exit}{pop}ifelse}forall dup T ne{pop F}if}FmBD/fmCN{fMND F fMCM
fMN ne{/fMOP fmGG{/fMKO fmGG{pop T}if}if}if dup/fMND exch def{pop pop}{exch dup
null ne{exch pop dup type dup/integertype eq exch/realtype eq or{fm_g}{setcolor
}ifelse}{pop{1 fm_g}if}ifelse}ifelse}FmBD/fill{FrameMacDict begin fMND{newpath}
{fm_f}ifelse end}fmPE/eofill{FrameMacDict begin fMND{newpath}{fm_e}ifelse end}
fmPE/stroke{FrameMacDict begin fMND{newpath}{fm_t}ifelse end}fmPE/imagemask{
FrameMacDict begin fMND{FmG nulldevive fm_m FmR}{fm_m}ifelse end}fmPE/fmNX{load
fMND{FmG fMa2 currentmatrix end nulldevice setmatrix exec currentpoint
FrameMacDict/FmR get exec moveto}{end exec}ifelse}fmBi def/show{FrameMacDict
begin/fm_s fmNX}fmPE/ashow{FrameMacDict begin/fm_a fmNX}fmPE/widthshow{
FrameMacDict begin/fm_w fmNX}fmPE/awidthshow{FrameMacDict begin/fm_y fmNX}fmPE
/kshow{FrameMacDict begin/RealKshow fmNX}fmPE/image{FrameMacDict begin fMCM fMN
ne fMCM fMK ne and{FmG/fMOP fmGG{nulldevice}{fMNg{{pop 0}}{{pop 1}}ifelse
settransfer}ifelse/fm_i load end exec FmR}{/fm_i load end exec}ifelse}fmPE/fMGM
T def/fMBM F def/findcmykcustomcolor{0 0 0 4 -1 roll 8 array astore}fmPE
/findrgbcustomcolor{FrameMacDict begin 4 1 roll 3 copy/fmRY fmGG exec 8 4 roll
4 -1 roll 8 array astore end}fmPE/findgraycustomcolor{0 0 0 exch 1 exch sub
exch findcmykcustomcolor}fmPE/findhsbcustomcolor{FrameMacDict begin 4 1 roll
gsave fm_h currentrgbcolor grestore 4 -1 roll findrgbcustomcolor end}fmPE
/setcustomcolor{FrameMacDict begin dup type dup/integertype eq exch/realtype eq
or not{1.0}if exch dup/fMCC exch fmSG/fMBM F def fMCM fMN eq{0 4 getinterval
aload pop 4{4 index mul 4 1 roll}repeat fmSK pop}{dup{7 get}stopped{pop 4 get}
if fmLM{exch pop 0 4 getinterval aload pop fMCM fMS eq{fMJK eq exch fMJY eq and
exch fMJM eq and exch fMJC eq and{1 exch sub F}{pop 1 T}ifelse}{5{pop}repeat 1
T}ifelse}{fMCM fMK eq{3 get F}{fMCM fMY eq{2 get F}{fMCM fMM eq{1 get F}{fMCM
fMC eq{0 get F}{pop 0 T}ifelse}ifelse}ifelse}ifelse 3 1 roll mul 1 exch sub
exch}ifelse/fMKO exch fmSG fmCN}ifelse end}fmPE/setoverprint{FrameMacDict begin
/fMOP exch fmSG null fmCN end}fmPE/currentoverprint{FrameMacDict begin/fMOP
fmGG end}fmPE/fmCC{fMCM fMN eq{fMGM fML1 or not{[/Pattern[/DeviceCMYK]]
setcolorspace fMCK 0 4 getinterval aload pop fMPt setcolor}{fMCK 3 get 1.0 ge{
fMCG fm_g}{fMAB not fMCl fMGM and and{0 1 3{fMCK exch get 1 fMCG sub mul}for
fmSK}{4 1 6{fMCK exch get fMGM{1 exch sub 1 fMCG sub mul 1 exch sub}{1.0 lt{
fMCG}{1}ifelse}ifelse}for fm_r}ifelse}ifelse}ifelse null/fMKO F fmSG}{fMBM{fMCG
F}{fMCK 0 4 getinterval aload fmLC{fMCM fMS eq{fMJK eq exch fMJY eq and exch
fMJM eq and exch fMJC eq and{fMCG F}{1 T}ifelse}{pop pop pop pop 1 T}ifelse}{
fMCM fMK eq{fMCG 1.0 exch sub mul 1.0 exch sub 4 1 roll pop pop pop F}{fMCM fMY
eq{pop fMCG 1.0 exch sub mul 1.0 exch sub 3 1 roll pop pop F}{fMCM fMM eq{pop
pop fMCG 1.0 exch sub mul 1.0 exch sub exch pop F}{fMCM fMC eq{pop pop pop fMCG
1.0 exch sub mul 1.0 exch sub F}{pop pop pop pop 1 T}ifelse}ifelse}ifelse}
ifelse}ifelse}ifelse/fMKO exch fmSG fMGM fML1 or not{[/Pattern[/DeviceGray]]
setcolorspace fMPt}{fMGM not fML1 and{dup 1 lt{pop fMCG}if}if}ifelse}ifelse
fmCN}FmBD/setgray{FrameMacDict begin fMCM fMN eq{F}{fMCM fMK eq{F}{fMCM fMS eq
fMJR 0 eq and fMJG 0 eq and fMJB 0 eq and{F}{pop 1 T}ifelse}ifelse}ifelse/fMKO
exch fmSG fmCN end}fmPE/setrgbcolor{FrameMacDict begin/fMBM F def fMCM fMN eq{
fm_r}{3 copy[4 1 roll]fmLR{fMCM fMS eq{fMJB eq exch fMJG eq and exch fMJR eq
and{0 F}{1 T}ifelse}{pop pop pop 1 T}ifelse}{/fmRY fmGG exec fMCM fMK eq{1.0
exch sub 4 1 roll pop pop pop F}{fMCM fMY eq{pop 1.0 exch sub 3 1 roll pop pop
F}{fMCM fMM eq{pop pop 1.0 exch sub exch pop F}{fMCM fMC eq{pop pop pop 1.0
exch sub F}{pop pop pop pop 1 T}ifelse}ifelse}ifelse}ifelse}ifelse/fMKO exch
fmSG fmCN}ifelse end}fmPE/sethsbcolor{FrameMacDict begin fMCM fMN eq{fm_h}{fm_h
currentrgbcolor setrgbcolor}ifelse end}fmPE/setcmykcolor where{pop/fmSK
/setcmykcolor load def}{/fmSK{4 1 roll 3{3 index add 0 fmax 1 fmin 1 exch sub 3
1 roll}repeat fm_r pop}FmBD}ifelse/currentcmykcolor where{pop}{
/currentcmykcolor{FrameMacDict begin currentrgbcolor/fmRY fmGG exec end}fmPE}
ifelse/setcmykcolor{FrameMacDict begin/fMBM F def fMCM fMN eq{fmSK}{4 copy[5 1
roll]fmLC{fMCM fMS eq{fMJK eq exch fMJY eq and exch fMJM eq and exch fMJC eq
and{0 F}{1 T}ifelse}{pop pop pop pop 1 T}ifelse}{fMCM fMK eq{1.0 exch sub 4 1
roll pop pop pop dup 1.0 ge}{fMCM fMY eq{pop 1.0 exch sub 3 1 roll pop pop dup
1.0 ge}{fMCM fMM eq{pop pop 1.0 exch sub exch pop dup 1.0 ge}{fMCM fMC eq{pop
pop pop 1.0 exch sub dup 1.0 ge}{pop pop pop pop 1 T}ifelse}ifelse}ifelse}
ifelse}ifelse/fMKO exch fmSG fmCN}ifelse end}fmPE/fMFl[0 .1 .3 .5 .7 .9 .97 1<
0f1e3c78f0e1c387><0f87c3e1f0783c1e><cccccccccccccccc><ffff0000ffff0000><814224
1818244281><0102040810204080><8040201008040201>]def fML1{/patScreenDict 7 dict
dup begin<0f1e3c78f0e1c387>[45{pop}{exch pop}.5 2 sqrt]FmBD<0f87c3e1f0783c1e>[
135{pop}{exch pop}.5 2 sqrt]FmBD<cccccccccccccccc>[0{pop}dup .5 2]FmBD<ffff0000
ffff0000>[90{pop}dup .5 2]FmBD<8142241818244281>[45{2 copy lt{exch}if pop}dup
.75 2 sqrt]FmBD<0102040810204080>[45{pop}{exch pop}.875 2 sqrt]FmBD<8040201008
040201>[135{pop}{exch pop}.875 2 sqrt]FmBD end def}{/fMPP 5 dict dup begin<0f87
c3e1f0783c1e>{3 setlinewidth -1 -1 moveto 9 9 lineto fm_t 4 -4 moveto 12 4
lineto fm_t -4 4 moveto 4 12 lineto fm_t}FmBD<0f1e3c78f0e1c387>{3 setlinewidth
-1 9 moveto 9 -1 lineto fm_t -4 4 moveto 4 -4 lineto fm_t 4 12 moveto 12 4
lineto fm_t}FmBD<8142241818244281>{1 setlinewidth -1 9 moveto 9 -1 lineto fm_t
-1 -1 moveto 9 9 lineto fm_t}FmBD<8040201008040201>{1 setlinewidth -1 -1 moveto
9 9 lineto fm_t 4 -4 moveto 12 4 lineto fm_t -4 4 moveto 4 12 lineto fm_t}FmBD<
0102040810204080>{1 setlinewidth -1 9 moveto 9 -1 lineto fm_t -4 4 moveto 4 -4
lineto fm_t 4 12 moveto 12 4 lineto fm_t}FmBD end def/fMPD 15 dict dup begin
/PatternType 1 def/PaintType 2 def/TilingType 3 def/BBox[0 0 8 8]def/XStep 8
def/YStep 8 def/PaintProc{begin fMPP fmBS known{fMPP fmBS get exec}{8 8 T[1 0 0
-1 0 8]fmBS fm_m}ifelse end}FmBD end def}ifelse/fMdp 72 0 fMdm dtransform dup
mul exch dup mul add sqrt def/freq fMdp dup 72 div round dup 0 eq{pop 1}if 8
mul div def/sangle 1 0 fMdm dtransform exch atan def sangle fMa2 rotate fMdm
fMa2 concatmatrix dup 0 get/sflipx exch def 3 get/sflipy exch def fML1{/fmgF{
fMa2 exch get mul 0 lt{-1}{1}ifelse}FmBD}if/fmPM fML1{{dup patScreenDict exch
known{patScreenDict exch get aload pop freq mul 5 2 roll fMa2 currentmatrix 1
get 0 ne{3 -1 roll 90 add 3 1 roll sflipx 1 fmgF sflipy 2 fmgF mul}{sflipx 0
fmgF sflipy 3 fmgF neg mul}ifelse 0 lt{exch pop}{pop}ifelse fMNg{{neg}fmcp}if
bind systemdict/setscreen get exec}{/fmBS fmXD/fM1B 0 def/fM0B 0 def freq 0
fMa2 currentmatrix 1 get 0 ne{90 add/pflipx sflipx 1 fmgF def/pflipy sflipy 2
fmgF def}{/pflipx sflipx 0 fmgF def/pflipy sflipy 3 fmgF neg def}ifelse{pflipy
mul/yy fmXD pflipx mul/xx fmXD/xindex xx 1 add 2 div 8 mul cvi def/yindex yy 1
add 2 div 8 mul cvi def fmBS yindex xindex 8 idiv add get 1 7 xindex 8 mod sub
bitshift and 0 ne fMNg{not}if{/fM1B fM1B 1 add def 1}{/fM0B fM0B 1 add def 0}
ifelse}setscreen fM0B fM0B fM1B add div fMNg{1.0 exch sub}if}ifelse/fMCG exch
def/fMGM F def fmCC}}{/fMPC 8 dict def{dup fMPC exch known{fMPC exch get}{dup
fMPD/fmBS 3 -1 roll put fMPD matrix makepattern dup fMPC 4 -1 roll 3 -1 roll
put}ifelse/fMCG 0 def/fMPt exch def/fMGM F def fmCC}}ifelse FmBD/fmgr{fMGM not{
/fMGM T def fML1{fMPH fmSH}if}if/fMCG exch def fmCC}FmBD/FmP{fMFl exch get dup
type/stringtype eq{fmPM}{fmgr}ifelse}FmBD/FmK{fMCK astore pop/fMBM F def fmCC}
FmBD/FmFB{0 0 0 1 0 0 0 fMCK astore pop/fMCG 0 def/fMBM T def fmCC}FmBD/fMOx
matrix def fMOx currentmatrix pop/FmSO{/FmOs save def fmSM fMOx setmatrix}FmBD
/FmIO{fmRM}FmBD/FmEO{FmOs restore}FmBD/fm3R[{.3 mul add 1}bind{.59 mul add 2}
bind{.11 mul add round cvi fMs exch fMi exch put/fMi fMi 1 add def 0 0}bind]def
/fm31{/fMi 0 def 0 exch 0 exch{exch fm3R exch get exec}forall pop pop fMs}FmBD
/fm41{0 exch 4 exch{exch 1 sub dup 0 eq{pop 4 1 roll 3 index add 255 fmin 255
exch sub .11 mul 3 1 roll 3 index add 255 fmin 255 exch sub .59 mul 3 1 roll 3
index add 255 fmin 255 exch sub .3 mul add add 255 fmin round cvi fMs exch 3
index exch put pop 1 add 4}if}forall pop pop fMs}FmBD fML1{/Fmi{save userdict
/fM7 3 -1 roll put/fM9 F def{{dup length 1 sub/fMGL fmXD/fMBC fmXD/fMNC fmXD
/fMRC fmXD/fMGC fMGL 1 add array def/setcolortransfer where{pop
currentcolortransfer/gryt fmXD/blut fmXD/grnt fmXD/redt fmXD 0 1 fMGL{/fMIx
fmXD/fMUC 1 fMRC fMIx get sub def/fMUM 1 fMNC fMIx get sub def/fMUY 1 fMBC fMIx
get sub def/fMk fMUC fMUM fmin fMUY fmin def/FmU fMk currentundercolorremoval
exec def fMRC fMIx 1 0 fMUC FmU sub fmax sub redt exec put fMNC fMIx 1 0 fMUM
FmU sub fmax sub grnt exec put fMBC fMIx 1 0 fMUY FmU sub fmax sub blut exec
put fMGC fMIx 1 fMk currentblackgeneration exec sub gryt exec put}for{fMGL mul
cvi fMRC exch get}{fMGL mul cvi fMNC exch get}{fMGL mul cvi fMBC exch get}{fMGL
mul cvi fMGC exch get}setcolortransfer{pop 0}setundercolorremoval{}
setblackgeneration/fM9 T def}{0 1 fMGL{fMGC exch dup dup fMRC exch get .3 mul
exch dup fMNC exch get .59 mul exch fMBC exch get .11 mul add add put}for{fMGL
mul cvi fMGC exch get}currenttransfer fmcp settransfer}ifelse}{dup length 1 sub
/fMGL fmXD/fMGC fmXD{fMGL mul cvi fMGC exch get}currenttransfer fmcp
settransfer}ifelse}{{{1 exch sub}currenttransfer fmcp settransfer}if}ifelse/fM5
fmXD/fM8 fmXD/fM6 fmXD/fM3 fmXD/fM4 fmXD translate rotate scale{-1 1 scale}if
/fM18 fM8 string def fM4 fM3 fM6[fM4 0 0 fM3 fM4 2 div fM3 2 div]{currentfile
fM18 fM5{readstring}{readhexstring}ifelse pop}fM9{{fM18}{fM18}T 3 colorimage}{
fm_i}ifelse fM7 restore}FmBD}{/Fmi{save userdict/fM7 3 -1 roll put/fM9 F def{{
dup length 1 sub/fMGL fmXD/fMBC fmXD/fMNC fmXD/fMRC fmXD[/Indexed/DeviceRGB
fMGL{dup fMRC exch get exch dup fMNC exch get exch fMBC exch get}]setcolorspace
}{dup length 1 sub/fMGL fmXD/fMGC fmXD[/Indexed/DeviceGray fMGL{fMGC exch get}]
setcolorspace}ifelse}{1 4 index bitshift 1 sub/fMGL fmXD[/Indexed/DeviceGray
fMGL 5 -1 roll{{fMGL div 1 exch sub}}{{fMGL div}}ifelse]setcolorspace}ifelse
/fM5 fmXD/fM8 fmXD/fM6 fmXD/fM3 fmXD/fM4 fmXD translate rotate scale{-1 1 scale
}if/fM18 fM8 string def 7 dict begin/ImageType 1 def/Width fM4 def/Height fM3
def/ImageMatrix[fM4 0 0 fM3 fM4 2 div fM3 2 div]def/DataSource{currentfile fM18
fM5{readstring}{readhexstring}ifelse pop}def/BitsPerComponent fM6 def/Decode[0
fMGL]def currentdict end fm_i fM7 restore}FmBD}ifelse/Fmci{save userdict/fM7 3
-1 roll put/fM5 fmXD/fM8 fmXD/fM6 fmXD/fM3 fmXD/fM4 fmXD/fM18 fM8 string def
/fMs fM18 0 fM18 length 3 idiv getinterval def translate rotate scale{-1 1
scale}if fM4 fM3 fM6[fM4 0 0 fM3 fM4 2 div fM3 2 div]fMCl{{currentfile fM18 fM5
{readstring}{readhexstring}ifelse pop}F 3 colorimage}{{currentfile fM18 fM5{
readstring}{readhexstring}ifelse pop fm31}fm_i}ifelse fM7 restore}FmBD/Fmc4{
save userdict/fM7 3 -1 roll put/fM5 fmXD/fM8 fmXD/fM6 fmXD/fM3 fmXD/fM4 fmXD
/fM18 fM8 string def/fMs fM18 0 fM18 length 4 idiv getinterval def translate
rotate scale{-1 1 scale}if fM4 fM3 fM6[fM4 0 0 fM3 fM4 2 div fM3 2 div]fMCl{{
currentfile fM18 fM5{readstring}{readhexstring}ifelse pop}F 4 colorimage}{{
currentfile fM18 fM5{readstring}{readhexstring}ifelse pop fm41}fm_i}ifelse fM7
restore}FmBD fML1{/fmAn{transform round .5 sub exch round .5 sub exch
itransform}FmBD/fmAc{transform round 1.5 sub exch round 1.5 sub exch itransform
}FmBD/fmDn{dtransform round exch round exch idtransform}FmBD/fmLn{0 dtransform
exch cvi 2 idiv 2 mul .1 add exch idtransform pop}FmBD/FmCv{fmDn 6 2 roll fmDn
6 2 roll fmDn 6 2 roll rcurveto}FmBD}{T setstrokeadjust/fmAn{}FmBD/fmAc{}FmBD
/fmDn{}FmBD/fmLn{}FmBD/FmCv{rcurveto}FmBD}ifelse/FmM{fmAn moveto}FmBD/M{moveto}
FmBD/N{0 rmoveto}FmBD/S{fm_s}FmBD/A{0 exch fm_a}FmBD/W{0 exch 32 exch fm_w}FmBD
/X{0 exch 0 32 5 2 roll fm_y}FmBD/fmQP{fML1 fMGM or not{FmG dup 1 fm_g exec FmR
}if exec}FmBD/FmB{newpath fmAn moveto}FmBD/FmL{rlineto}FmBD/FmAL{fmAn lineto}
FmBD/FmSo{fmLn setlinewidth setlinecap{fm_t}fmQP 0 0 moveto}FmBD/FmS{fmLn
setlinewidth closepath{fm_t}fmQP 0 0 moveto}FmBD/FmDS{fmLn setlinewidth
setlinecap{closepath}if setdash{fm_t}fmQP[]0 setdash 0 0 moveto}FmBD/FmFl{FmG{
fm_e}fmQP FmR}FmBD/fmq{fmDn 4 2 roll fmAn newpath moveto 1 index 0 rlineto 0
exch rlineto neg 0 rlineto closepath}FmBD/FmqP{fmq fmLn setlinewidth{fm_t}fmQP
0 0 moveto}FmBD/FmqF{fmq FmG{fm_f}fmQP FmR}FmBD/FmKp{{currentpoint}stopped{F 5
1 roll}{T 7 3 roll}ifelse fmDn 4 2 roll fmAn newpath moveto 1 index 0 rlineto 0
exch rlineto neg 0 rlineto closepath clip{moveto}{newpath}ifelse}FmBD/FmKb{{
currentpoint}stopped}FmBD/FmKe{clip{newpath}{moveto}ifelse}FmBD/FmAF{FmG
newpath fmAn translate not{0.0 0.0 moveto}if rotate fmDn scale 0.0 0.0 1.0 5 3
roll arc closepath{fm_f}fmQP FmR}FmBD/FmAP{FmG{setdash}if fmLn setlinewidth
setlinecap fmSM newpath 2 index 2 div add exch 3 index 2 div sub exch fmAn 2
index 2 div sub exch 3 index 2 div add exch translate rotate scale 0.0 0.0 1.0
5 3 roll exch arcn{closepath}if fmRM{fm_t}fmQP FmR}FmBD/FmST{FmG fmAn translate
.3 fmLn setlinewidth 0 setlinecap 0 setlinejoin newpath 1 fm_g 0 0 10 0 360 arc
fm_f 0 fm_g 0 0 10 0 360 arc fm_t 36{1 0 moveto 0 0 10 -2.5 2.5 arc fm_f 10
rotate}repeat FmR}FmBD/FmSL{FmG fmAn translate .25 fmLn setlinewidth 0
setlinecap 0 setlinejoin newpath 1 fm_g 0 0 10 0 360 arc fm_f 0 fm_g 10 .5 fmLn
neg .1{0 0 3 -1 roll 0 360 arc fm_t}for FmR}FmBD/FrameEr where{pop}{userdict
/FrameEr(\000)put}ifelse/fMSJ 100 string def/fmXC{userdict/FrameEndPictSave 2
index put FmE{countdictstack userdict begin/showpage{}def/FrameDictStackDepth
exch def count/FrameStackDepth exch def}if userdict/FrameSuccessfull false put
FrameMacDict/fMHq get/$brkpage where dup{exch pop}if or{userdict
/FrameEndPictStopped false put}{userdict/FrameEndPictStopped true put
currentfile cvx stopped pop FrameSuccessfull not{systemdict/clear get exec
userdict/FrameEr get 0 1 put FrameMacDict begin FmG systemdict/initmatrix get
exec 0 systemdict/setgray get exec clippath{pathbbox}stopped{100 100 512 692}if
exch pop add 2. div newpath moveto(Courier-BoldOblique)findfont 18 scalefont
setfont FrameEr1 fm_s( \()fm_s $error begin errorname 20 string cvs fm_s(, )
fm_s/command load 128 string cvs fm_s end(\))fm_s FrameEr2 print flush
FrameMacDict/fMSJ get{dup currentfile exch{readline}stopped{pop exch pop T}if
not{exit}if(EndFrame5Picture)eq{exit}if}loop grestore end}if userdict
/FrameSuccessfull false put userdict/FrameEndPictStopped false put FrameMacDict
/fmIR get exec}ifelse}fmBi def/FmEP{save userdict/fM7 3 -1 roll put fMEd{
userdict 3 1 roll put}forall setoverprint{fMN FmSP}if[/fMef/fMet/fMeh/fMew/fMey
/fMex/fMei/fMej/fMek/fMel]{fmXD}forall fMex fMey translate fMet rotate fMew
fMeh scale fMef{-1 1 scale}if 1 fMej fMel sub div 1 fMek fMei sub div scale
fMej fMel add 2 div neg fMei fMek add 2 div neg translate 0 setgray 0
setlinecap 1 setlinewidth 0 setlinejoin 10 setmiterlimit[]0 setdash newpath
fML1 not{F setstrokeadjust}if T fmXC}FmBD/FmPI{newpath 0 0 moveto F fmXC}FmBD
/FmPc{save userdict/fM7 3 -1 roll put newpath 3 index neg 3 index neg translate
1 -1 scale 0.0 0.0 moveto T fmXC}FmBD/fmIR{FrameEndPictSave{fM7 type/savetype
eq{end/FrameDictStackDepth where{pop countdictstack FrameDictStackDepth sub dup
0 gt{{end}repeat}{pop}ifelse count FrameStackDepth sub dup 0 gt{{pop}repeat}{
pop}ifelse}if fM7 restore}if}if FrMacBegin}FmBD userdict/EndFrame5Picture{
userdict/FrameEndPictSave 3 -1 roll put userdict/FrameEndPictStopped get{
userdict/FrameSuccessfull true put stop}{FrameMacDict/fmIR get exec}ifelse}fmBi
put/alphaimage where{pop}{/alphaimage{1 ne{limitcheck}if not{limitcheck}if pop
image}fmPE}ifelse/fmDE{systemdict/initgraphics get exec clippath{pathbbox}
stopped{100 100 512 692}if exch pop add 2. div newpath moveto
(Courier-BoldOblique)findfont 18 scalefont setfont currentpoint 2 copy FrameEr3
fm_s 20 sub 2 copy moveto FrameEr4 fm_s 20 sub 2 copy moveto(\()fm_s statusdict
/jobname get fm_s(\))fm_s 20 sub moveto FrameEr5 fm_s showpage}FmBD/cd where{
dup/cd get/fmRC fmXD/cd{FrameMacDict begin FrameEr 0 get 0 ne{fmDE}if/fmRC load
end exec}fmBi put}{/endp where{dup/endp get/fMRE fmXD/endp{FrameMacDict/fMRE
get exec FrameEr 0 get 0 ne{FrameMacDict begin currentfile fMSJ{readline}
stopped{pop exch pop true}if pop(%%Trailer)eq{fmDE}if end}if}fmBi put}if}ifelse
systemdict/setpacking known{fMSP setpacking}if end
%%EndProcSet
%%FRMSetup
FrameMacDict begin
/FrameEr1(PostScript error)def
/FrameEr2(A PostScript error occurred. FrameMaker is attempting recovery.)def
/FrameEr3(FrameMaker has detected one or more)def
/FrameEr4(PostScript errors in this document.)def
/FrameEr5(Please check your output.)def
end
%%FRMEndSetup
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
%RBIIncludePageSlotInvocation
mTSsetup
pmSVsetup
initializepage
(David Gerhard; page: 1 of 8)setjob
%%EndPageSetup
gS 0 0 552 728 rC
0 0 :M
FrMacBegin
0 FmP
0 FmSP
FmE
0 0 :M
f148 sf
( )S
3 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
455.865 725.022 M (P)S
-0.182 N (age )S
(1)S
( of )S
(8)S
FmE
3 0 :M
f175 sf
( )S
7 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
237.253 53 M (the SAP-2)S
FmE
8 0 :M
f148 sf
( )S
11 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
243.687 77 M (cmpt-150-arc)S
190.685 99 M (Sections 8-8,  8-9, 9-4, 9-5, 9.6, 9.8)S
123 117 M (1.)S
9 N (W)S
-0.961 N (e\325)S
-0.12 N (ll do this in bits and pieces, doing the be)S
-0.182 N (ginning of each section \336)S
(rst.)S
FmE
11 0 :M
f188 sf
( )S
15 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 145.667 M (I.)S
43.773 N (Intr)S
-0.289 N (o)S
FmE
15 0 :M
f148 sf
( )S
18 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 165 M (1.)S
9 N (The SAP-2 adds a lot of functionality to the SAP-1 hardw)S
-0.12 N (are, and we\325)S
-0.12 N (ll )S
141 179 M -0.107(present this to see what the hardw)W
-0.12 N -0.107(are does, b)W
-0.24 N -0.107(ut the important additions are to )W
141 193 M (the instruction set.)S
123 211 M (2.)S
9 N (The hardw)S
-0.12 N (are diagram and instruction set are on the web)S
-0.48 N (.)S
FmE
18 0 :M
f201 sf
( )S
21 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 233 M (A.)S
15.337 N (What\325)S
-0.445 N (s new)S
FmE
21 0 :M
f148 sf
( )S
24 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 251 M (1.)S
9 N (W)S
-0.961 N (ell, before you get w)S
-0.12 N (ork)S
-0.12 N (ed up, nothing is really that ne)S
-0.302 N (w)S
-0.782 N (. Datapath is big-)S
141 265 M (ger)S
-0.48 N (, b)S
-0.24 N (ut operation remains the same.)S
123 283 M (2.)S
9 N (Datapath size is still 8 bits \(i.e. accumulator is still 8 bits, for e)S
-0.182 N (g\))S
123 301 M (3.)S
9 N (the RAM is 64k no)S
-0.302 N (w)S
-0.782 N (, so we need 16 bits to address it, so the b)S
-0.24 N (us is no)S
-0.302 N (w 16 )S
141 315 M (bits.)S
123 333 M (4.)S
9 N (Control sequencer is much bigger as a result of all the e)S
-0.182 N (xtra re)S
-0.182 N (gisters we )S
141 347 M (added, b)S
-0.24 N (ut we w)S
-0.12 N (on\325)S
-0.217 N (t w)S
-0.12 N (orry about what\325)S
-0.662 N (s inside.)S
FmE
24 0 :M
f201 sf
( )S
27 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 369 M (B.)S
15.996 N (New Registers)S
FmE
27 0 :M
f148 sf
( )S
30 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 387 M (1.)S
9 N (MEMOR)S
-0.782 N (Y D)S
-0.48 N (A)S
-1.333 N (T)S
-1.116 N (A REGISTER:  )S
-0.217 N (This re)S
-0.182 N (gister holds the result of a memory )S
141 401 M (access, so we can do other things with the b)S
-0.24 N (us while the memory access hap-)S
141 415 M (pens.)S
123 433 M (2.)S
9 N (B IS NO)S
-0.422 N (W CALLED )S
-0.217 N (TMP: this mak)S
-0.12 N (es more sense because it really is an )S
141 447 M (implementation re)S
-0.182 N (gister)S
-0.662 N (. )S
123 465 M (3.)S
9 N (B )S
-0.662 N (AND C REGISTERS: these can hold operands and can be used for other )S
141 479 M (instructions.  )S
-0.217 N (These are archetectural re)S
-0.182 N (gisters, because the)S
-0.182 N (y sho)S
-0.302 N (w up in the )S
141 493 M (instructions \(as we\325)S
-0.12 N (ll see\))S
FmE
30 0 :M
f201 sf
( )S
33 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 515 M (C.)S
15.337 N (Other new things \(will become clear as we do examples\))S
FmE
33 0 :M
f148 sf
( )S
36 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 533 M (1.)S
9 N -0.185(Adder/Subtractor is no)W
-0.302 N -0.185(w called the )W
-0.662 N -0.185(ARITHMETIC/LOGIC UNIT)W
-0.891 N -0.185(, because it )W
141 547 M (will be doing other things besides adding and subtraction, speci\336)S
(cally logic )S
141 561 M (operations lik)S
-0.12 N (e complement etc.)S
123 579 M (2.)S
9 N (\322\337)S
(ags\(0:1\)\323 will tell us useful information about the )S
-0.662 N (ALU operations we per)S
-0.24 N (-)S
141 593 M (form)S
123 611 M (3.)S
9 N -0.299(Addresses are no)W
-0.302 N -0.299(w 16 bits, and opcodes are no)W
-0.302 N -0.299(w 8 bits \(because we will ha)W
-0.24 N (v)S
-0.182 N -0.299(e )W
141 625 M (more instructions than we had room for in 4 bits of opcode\) so instructions )S
141 639 M (tak)S
-0.12 N (e 3 memory locations each \(at least\))S
123 657 M (4.)S
9 N (Instructions can no)S
-0.302 N (w be v)S
-0.302 N (ariable length: the \336)S
(rst byte we fetch \(the opcode\) )S
141 671 M (tells us ho)S
-0.302 N (w man)S
-0.182 N (y more bytes of the instruction to fetch.)S
FmE
endp
showpage
%%PageTrailer
%%Page: 2 2
%%BeginPageSetup
%RBIIncludePageSlotInvocation
mTSsetup
pmSVsetup
initializepage
(David Gerhard; page: 2 of 8)setjob
%%EndPageSetup
gS 0 0 552 728 rC
36 0 :M
FrMacBegin
0 FmP
0 FmSP
FmE
36 0 :M
f240 sf
( )S
39 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 13 M (the SAP-2)S
FmE
39 0 :M
f148 sf
( )S
42 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 725.022 M (P)S
-0.182 N (age )S
(2)S
( of )S
(8)S
FmE
42 0 :M
f188 sf
( )S
46 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 87.667 M (II.)S
37.547 N (Basics of assembly languages)S
FmE
46 0 :M
f201 sf
( )S
49 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 111 M (A.)S
15.337 N (Or)S
-0.12 N (ganizing principle: )S
-0.36 N (T)S
-0.891 N (ypes of instructions)S
FmE
49 0 :M
f148 sf
( )S
52 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 129 M (1.)S
9 N (D)S
-0.48 N (A)S
-1.333 N (T)S
-1.116 N (A )S
-0.217 N (TRANSFER: these instructions mo)S
-0.182 N (v)S
-0.182 N (e data from place to place)S
141 147 M (a\))S
8.681 N (REGISTER-REGSITER )S
-0.217 N (TRANSFER: between CPU re)S
-0.182 N (gisters)S
141 165 M (b\))S
8.007 N (REGSITER-MEMOR)S
-0.782 N (Y or LO)S
-0.422 N (AD/ST)S
-0.217 N (ORE: between mem and re)S
-0.182 N (gisters.)S
123 183 M (2.)S
9 N (ARITHMETIC/LOGIC: )S
-0.217 N (The instructions alter data. )S
141 201 M (a\))S
8.681 N (ARITHMETIC: add, subtract, mult, etc)S
141 219 M (b\))S
8.007 N (LOGICAL: and, or)S
-0.48 N (, bit set and bit testing)S
141 237 M (c\))S
8.681 N (SHIFT/R)S
-0.48 N (O)S
-0.48 N (T)S
-1.116 N (A)S
-1.333 N (TE: duh shifts and rotates.)S
123 255 M (3.)S
9 N (FLO)S
-0.422 N (W)S
-0.782 N (-OF-CONTR)S
-0.48 N (OL)S
141 273 M (a\))S
8.681 N (JUMP: start e)S
-0.182 N (x)S
-0.182 N (ecuting instructions at a ne)S
-0.302 N (w address)S
141 291 M (b\))S
8.007 N (BRANCH: goto a ne)S
-0.302 N (w address if a condition is met)S
141 309 M (c\))S
8.681 N (SUBR)S
-0.48 N (OUTINE: goto a ne)S
-0.302 N (w address, using paramaters, with the capabil-)S
159 323 M (ity to return.)S
123 341 M (4.)S
9 N (almost all assembly languages or)S
-0.217 N (g)S
-0.062 N (anize their instructions more or less lik)S
-0.12 N (e )S
141 355 M (this.  it\325)S
-0.662 N (s just a matter of \336)S
(guring out the speci\336)S
(c syntax \(which is wh)S
-0.062 N (y we )S
141 369 M (ha)S
-0.24 N (v)S
-0.182 N (e the manuals!\))S
FmE
52 0 :M
f201 sf
( )S
55 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 391 M (B.)S
15.996 N (Or)S
-0.12 N (ganizing Principle: Operand F)S
-0.302 N (ormat \(addr)S
-0.217 N (essing modes\))S
FmE
55 0 :M
f148 sf
( )S
58 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 409 M (1.)S
9 N (So f)S
-0.12 N (ar we ha)S
-0.24 N (v)S
-0.182 N (e seen operands speci\336)S
(ed as memory locations in the instruc-)S
141 423 M (tion, or speci\336)S
(ed as re)S
-0.182 N (gisters.)S
123 441 M (2.)S
9 N (W)S
-0.961 N (e\325)S
-0.12 N (ll look at more of these as we encounter them.)S
FmE
58 0 :M
f188 sf
( )S
62 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 469.667 M (III.)S
31.32 N (Instructions)S
FmE
62 0 :M
f201 sf
( )S
65 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 493 M (A.)S
15.337 N (Load/Stor)S
-0.217 N (e instructions)S
FmE
65 0 :M
f148 sf
( )S
68 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 511 M (1.)S
9 N (The SAP-2 can no)S
-0.302 N (w store data into the RAM as well as load data.)S
123 529 M (2.)S
9 N (Recall: instructions that need a memory )S
141 543 M (address are 3 bytes long: one for the )S
141 557 M (opcode, and the remaining 2 for the high )S
141 571 M (and lo)S
-0.302 N (w halv)S
-0.182 N (es \(bytes\) of the address.)S
123 589 M (3.)S
9 N (This is )S
FmE
68 0 :M
f201 sf
( )S
71 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
176.332 589 M (dir)S
-0.217 N (ect addr)S
-0.217 N (essing)S
FmE
71 0 :M
f148 sf
( )S
74 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
264.208 589 M (: specifying the )S
141 603 M (operand by including the memory address.)S
123 621 M (4.)S
9 N (Example: Store what\325)S
-0.662 N (s in the )S
-0.662 N (A re)S
-0.182 N (gister in memory 3c55h)S
141 639 M (a\))S
8.681 N (SAP-2: sta 3c55 is translated to 32h / 55h / 3ch)S
141 657 M (b\))S
8.007 N (HC11: staa 3c55 is translated to b7h / 3ch / 55)S
141 675 M (c\))S
8.681 N (Note that HC11 and SAP-2 use dif)S
-0.302 N (ferent order for the halv)S
-0.182 N (es \(bytes\) of )S
FmE
352 520 158 76 rC
74 0 :M
FrMacBegin
352 521 158 75 FmKp
0 0 0 1 0 0 0 FmK
0 FmP
0.5 403 538 94 18 FmqP
0.5 403 556 94 18 FmqP
0.5 403 574 94 18 FmqP
FmE
74 0 :M
( )S
77 0 :M
FrMacBegin
352 521 158 75 FmKp
0 0 0 1 0 0 0 FmK
0 FmP
392 534 M (7)S
103 N (0)S
426 533 M (memory)S
392 548 M (k)S
382 568 M (k+1)S
382 587 M (k+2)S
358 554 M (bytes)S
426 551 M (opcode)S
408 567 M (address\(lo)S
-0.302 N (w byte\))S
407 586 M (address\(high byte\))S
FmE
endp
showpage
%%PageTrailer
%%Page: 3 3
%%BeginPageSetup
%RBIIncludePageSlotInvocation
mTSsetup
pmSVsetup
initializepage
(David Gerhard; page: 3 of 8)setjob
%%EndPageSetup
gS 0 0 552 728 rC
77 0 :M
FrMacBegin
0 FmP
0 FmSP
FmE
77 0 :M
f240 sf
( )S
80 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
453.337 13 M (the SAP-2)S
FmE
80 0 :M
f148 sf
( )S
83 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
455.865 725.022 M (P)S
-0.182 N (age )S
(3)S
( of )S
(8)S
159 85 M (the address.)S
159 103 M (\(1\))S
13.014 N (in HC11, the most signi\336)S
(cant byte comes \336)S
(rst \(smaller address\))S
159 121 M (\(2\))S
13.014 N (in  SAP-2, the least signi\336)S
(cant byte comes \336)S
(rst.)S
141 139 M (d\))S
8.007 N (Note also that the instructions ha)S
-0.24 N (v)S
-0.182 N (e dif)S
-0.302 N (ferent opcodes - )S
-0.217 N (This is not sur)S
-0.24 N (-)S
159 153 M (prising, as the dif)S
-0.302 N (ferent instruction sets ha)S
-0.24 N (v)S
-0.182 N (e dif)S
-0.302 N (ferent instructions etc.)S
141 171 M (e\))S
8.681 N (W)S
-0.961 N (e \336)S
(nd the opcode for the HC11 instruction by looking in appendix )S
-0.662 N (A)S
141 189 M (f\))S
10.014 N (it tells us that if we w)S
-0.12 N (ant to store what\325)S
-0.662 N (s in \322)S
-0.961 N (A\323 to a tw)S
-0.12 N (o-byte memory )S
159 203 M (address, we use opcode 67.)S
141 221 M (g\))S
8.007 N (If you look, it also tells us that this is called \322e)S
-0.182 N (xtended\323 addressing.  F)S
-0.182 N (or )S
159 235 M (the HC11, Direct addressing just lik)S
-0.12 N (e we use it, e)S
-0.182 N (xcept with the most sig-)S
159 249 M (ni\336)S
(cant byte =\32300h\323.  )S
141 267 M (h\))S
8.007 N (Extended addressing  in the HC11 is direct addressing using the full 16 )S
159 281 M (bit address.)S
123 299 M (5.)S
9 N -0.194(Note that while the HC11 has staa and stab, the SAP-2 doesn\325)W
-0.217 N -0.194(t ha)W
-0.24 N (v)S
-0.182 N -0.194(e stb or stc)W
141 317 M (a\))S
8.681 N (This kind of asymmetry is common in assembly language design - some )S
159 331 M (other function w)S
-0.12 N (as deemed more important in the SAP-2.)S
FmE
83 0 :M
f201 sf
( )S
86 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 353 M (B.)S
15.996 N (Immediate Operands)S
FmE
86 0 :M
f148 sf
( )S
89 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 371 M (1.)S
9 N (An immediate operand is speci\336)S
(ed in the instruction itself instead of mem-)S
141 385 M (ory)S
-0.782 N (.)S
123 403 M (2.)S
9 N (Instead of going to memory to \336)S
(nd the v)S
-0.302 N (alue, the v)S
-0.302 N (alue is in the instruction )S
141 417 M (after the opcode, where the address w)S
-0.12 N (as in direct addressing.)S
123 435 M (3.)S
9 N (This is called immediate addressing.)S
123 453 M (4.)S
9 N (It is used frequently for small inte)S
-0.182 N (gers \(i.e. )S
FmE
89 0 :M
f274 sf
( )S
92 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
348.062 453 M (\261)S
FmE
92 0 :M
f148 sf
( )S
95 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
354.647 453 M (1,2,3, ascii characters etc\))S
123 471 M (5.)S
9 N (It is more ef)S
-0.302 N (\336)S
(cient than direct addressing because it needs only one memory )S
141 485 M (fetch after the opcode \(to fetch the ne)S
-0.182 N (xt chunk of the instruction\))S
141 503 M (a\))S
8.681 N (Direct addressing needs tw)S
-0.12 N (o memory fetches: Get the ne)S
-0.182 N (xt chunk of the )S
159 517 M (instruction, which is the address, then use that address to get the data. )S
123 535 M (6.)S
9 N (Example:  to load ascii \322Z\323 into re)S
-0.182 N (gister B. \(SAP-2\))S
141 553 M (a\))S
8.681 N (Instruction code is MVI \(Mo)S
-0.182 N (v)S
-0.182 N (e Immediate\))S
141 571 M (b\))S
8.007 N (The he)S
-0.182 N (x code for ascii \322Z\323 is 5ah)S
141 589 M (c\))S
8.681 N (The full instruction is MVI B, 5ah)S
141 607 M (d\))S
8.007 N (and the machine language for the full )S
159 621 M (instruction is 06h \336)S
(rst byte, 5ah second byte. \(as sho)S
-0.302 N (wn\))S
123 639 M (7.)S
9 N (And in HC11:)S
141 657 M (a\))S
8.681 N (instruction code is LD)S
-0.48 N (A \(load accumulator\))S
141 675 M (b\))S
8.007 N (The v)S
-0.182 N (ersion we w)S
-0.12 N (ant is LD)S
-0.48 N (AB \(machine code c6h\))S
FmE
375 545 135 62 rC
95 0 :M
FrMacBegin
375.032 545 134.968 61.024 FmKp
0 0 0 1 0 0 0 FmK
0 FmP
0.5 403.032 562 94 18 FmqP
0.5 403.032 580 94 18 FmqP
FmE
95 0 :M
( )S
98 0 :M
FrMacBegin
375.032 545 134.968 61.024 FmKp
0 0 0 1 0 0 0 FmK
0 FmP
392.032 558 M (7)S
103 N (0)S
426.032 557 M (memory)S
392.032 572 M (k)S
382.032 592 M (k+1)S
442 572 M (06h)S
444 593 M (5ah)S
FmE
endp
showpage
%%PageTrailer
%%Page: 4 4
%%BeginPageSetup
%RBIIncludePageSlotInvocation
mTSsetup
pmSVsetup
initializepage
(David Gerhard; page: 4 of 8)setjob
%%EndPageSetup
gS 0 0 552 728 rC
98 0 :M
FrMacBegin
0 FmP
0 FmSP
FmE
98 0 :M
f240 sf
( )S
101 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 13 M (the SAP-2)S
FmE
101 0 :M
f148 sf
( )S
104 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 725.022 M (P)S
-0.182 N (age )S
(4)S
( of )S
(8)S
141 85 M (c\))S
8.681 N (The full instruciton is LD)S
-0.48 N (AB #5ah.  )S
-0.217 N (The # )S
159 99 M -0.774(indicates an immediate operand \(see chap 6\).  )W
159 113 M (The machine code looks lik)S
-0.12 N (e:)S
FmE
104 0 :M
f201 sf
( )S
107 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 135 M (C.)S
15.337 N (Some notes on opcodes)S
FmE
107 0 :M
f148 sf
( )S
110 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 153 M (1.)S
9 N (W)S
-0.961 N (e\325)S
-0.601 N (re looking at tw)S
-0.12 N (o assembly languages at the same time, and the)S
-0.182 N (y do )S
141 167 M (things a bit dif)S
-0.302 N (ferently)S
-0.782 N (.)S
123 185 M (2.)S
9 N (The OPCODE is what tells the computer what to do, i.e. ho)S
-0.302 N (w man)S
-0.182 N (y more )S
141 199 M (bytes to fetch and what to do with them.)S
123 217 M (3.)S
9 N (Dif)S
-0.302 N (ferent assembly languages use opcodes in dif)S
-0.302 N (ferent w)S
-0.12 N (ays.  )S
123 235 M (4.)S
9 N (F)S
-0.182 N (or e)S
-0.182 N (xample, tak)S
-0.12 N (e these tw)S
-0.12 N (o operations: Load re)S
-0.182 N (gister )S
-0.662 N (A with the immediate )S
141 249 M (v)S
-0.302 N -0.145(alue 2ah \(A <- 2ah\), and Load re)W
-0.182 N -0.145(gister )W
-0.662 N -0.145(A with the v)W
-0.302 N -0.145(alue in memory location )W
141 263 M (2ah \(A <- M[2ah]\).)S
141 281 M (a\))S
8.681 N (in SAP-2, )S
159 299 M (\(1\))S
13.014 N (we use MVI )S
-0.662 N (A, 2ah for the immediate   \(3eh / 2ah\))S
159 317 M (\(2\))S
13.014 N (and LD)S
-0.48 N (A  002ah for the direct.    \(3ah / 2ah / 00h\))S
141 335 M (b\))S
8.007 N (in HC11, )S
159 353 M (\(1\))S
13.014 N (we use LD)S
-0.48 N (AA #2ah for immediate   \(86h / 2ah\))S
159 371 M (\(2\))S
13.014 N (and LD)S
-0.48 N (AA 002ah for the direct    \(b6h / 00h / 2ah\))S
123 389 M (5.)S
9 N (SAP-2 uses dif)S
-0.302 N (ferent mnemonics for the dif)S
-0.302 N (ferent addressing modes, b)S
-0.24 N (ut )S
141 403 M -0.021(HC11 uses the same mnemonic and the addressing mode is distinguished by )W
141 417 M (the pre\336)S
(x to the operand.)S
123 435 M (6.)S
9 N (Note that in both cases, the operand is dif)S
-0.302 N (ferent for dif)S
-0.302 N (ferent addressing )S
141 449 M (modes.)S
FmE
110 0 :M
f201 sf
( )S
113 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 471 M (D)S
-0.24 N (.)S
15.577 N (Inher)S
-0.217 N (ent or implied Operands)S
FmE
113 0 :M
f148 sf
( )S
116 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 489 M (1.)S
9 N -0.159(If there is an instruction that al)W
-0.12 N (w)S
-0.12 N -0.159(ays uses the same operand, we don\325)W
-0.217 N -0.159(t need to )W
141 503 M (e)S
-0.182 N (xplicitly state it.  the operand is INHERENT in the instruction.)S
123 521 M (2.)S
9 N (The opcode is all we need in this case.)S
123 539 M (3.)S
9 N (This is called INHERENT or IMPLIED addressing mode.)S
123 557 M (4.)S
9 N (All of the SAP-1 instructions used inherent addressing - the )S
-0.662 N (A re)S
-0.182 N (gister w)S
-0.12 N (as )S
141 571 M (al)S
-0.12 N (w)S
-0.12 N (ays implied \(e)S
-0.182 N (xcept in HL)S
-1.104 N (T\).)S
123 589 M (5.)S
9 N (The re)S
-0.182 N (gister - re)S
-0.182 N (gister transfer instructions in SAP-2 are inherent.  )S
123 607 M (6.)S
9 N (EXAMPLE: if we w)S
-0.12 N (ant to mo)S
-0.182 N (v)S
-0.182 N (e what\325)S
-0.662 N (s in )S
-0.662 N (A into B \(B<-A\) we use the )S
141 621 M -0.093(instruction \322MO)W
-0.601 N -0.093(V )W
-0.662 N -0.093(A,B\323.  )W
-0.217 N -0.093(The opcode is 78h, and the operands \(A and B\) are )W
141 635 M (implied in the opcode.)S
123 653 M (7.)S
9 N -0.137(The comprable HC11 instruction is )W
-0.217 N (T)S
-1.116 N -0.137(AB \(transfer )W
-0.662 N -0.137(A to B\).  In this case, e)W
-0.302 N (v)S
-0.182 N -0.137(en )W
141 667 M (the assembly language has no operands.  )S
-0.217 N (The opcode is 16h and that\325)S
-0.662 N (s all )S
141 681 M (there is.)S
FmE
375 77 135 62 rC
116 0 :M
FrMacBegin
375.032 77 134.968 61.024 FmKp
0 0 0 1 0 0 0 FmK
0 FmP
0.5 403.032 94 94 18 FmqP
0.5 403.032 112 94 18 FmqP
FmE
116 0 :M
( )S
119 0 :M
FrMacBegin
375.032 77 134.968 61.024 FmKp
0 0 0 1 0 0 0 FmK
0 FmP
392.032 90 M (7)S
103 N (0)S
426.032 89 M (memory)S
392.032 104 M (k)S
382.032 124 M (k+1)S
442 104 M (c6h)S
444 125 M (5ah)S
FmE
endp
showpage
%%PageTrailer
%%Page: 5 5
%%BeginPageSetup
%RBIIncludePageSlotInvocation
mTSsetup
pmSVsetup
initializepage
(David Gerhard; page: 5 of 8)setjob
%%EndPageSetup
gS 0 0 552 728 rC
119 0 :M
FrMacBegin
0 FmP
0 FmSP
FmE
119 0 :M
f240 sf
( )S
122 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
453.337 13 M (the SAP-2)S
FmE
122 0 :M
f148 sf
( )S
125 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
455.865 725.022 M (P)S
-0.182 N (age )S
(5)S
( of )S
(8)S
123 85 M (8.)S
9 N (Another e)S
-0.182 N (xample: in SAP-2, the )S
-0.662 N (ADD instruction implies )S
-0.662 N (ADD to )S
-0.662 N (A.  )S
141 103 M (a\))S
8.681 N (ADD B e)S
-0.182 N (x)S
-0.182 N (ecutes )S
-0.662 N (A <- )S
-0.662 N (A+B, and the opcode is \32280h\323, no operands.)S
141 121 M (b\))S
8.007 N -0.226(in HC11, the instruction is )W
-0.662 N (AB)S
-0.422 N -0.226(A \(Add B to )W
-0.662 N -0.226(A\), and the machine language )W
159 135 M (is simply the opcode \3221bh\323)S
123 153 M (9.)S
9 N (Note that unlik)S
-0.12 N (e direct and immediate oparands, inherent addressing doesn\325)S
-0.217 N (t )S
141 167 M -0.418(tell you an)W
-0.182 N -0.418(ything about where the operand is. It could be a re)W
-0.182 N (gister)S
-0.48 N -0.418(, or it could )W
141 181 M (be a constant \(increment a re)S
-0.182 N (gister\) or other things \(as we\325)S
-0.12 N (ll see\))S
123 199 M (10.)S
3 N -0.103(And be a)W
-0.182 N (w)S
-0.12 N -0.103(are that it is possible for each operand of an instruction to be spec-)W
141 213 M (i\336)S
(ed with a dif)S
-0.302 N (ferent addressing mode.)S
FmE
125 0 :M
f201 sf
( )S
128 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 235 M (E.)S
15.996 N (Register Operands)S
FmE
128 0 :M
f148 sf
( )S
131 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 253 M (1.)S
9 N (Re)S
-0.182 N (gisters are v)S
-0.182 N (ery common inherent operands.  In f)S
-0.12 N (act, all of the e)S
-0.182 N (xamples )S
141 267 M (we ha)S
-0.24 N (v)S
-0.182 N (e seen so f)S
-0.12 N (ar of inherent operands ha)S
-0.24 N (v)S
-0.182 N (e been re)S
-0.182 N (gisters.)S
123 285 M (2.)S
9 N (There is a special name for inherent operands that are re)S
-0.182 N (gisters - Re)S
-0.182 N (gister )S
141 299 M -0.292(addressing. It\325)W
-0.662 N -0.292(s a little more useful, though the HC11 doesn\325)W
-0.217 N -0.292(t use it e)W
-0.182 N (xplicityl.)S
FmE
131 0 :M
f201 sf
( )S
134 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 321 M (F)S
-1.321 N (.)S
17.991 N (Logical instructions)S
FmE
134 0 :M
f148 sf
( )S
137 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 339 M (1.)S
9 N (W)S
-0.961 N (e\325)S
-0.601 N (v)S
-0.182 N (e look)S
-0.12 N (ed brie\337)S
(y at arithmetic instructions \(add etc\) b)S
-0.24 N (ut one of the )S
141 353 M (impro)S
-0.182 N (v)S
-0.182 N (ements in the SAP-2 is this \322)S
-0.961 N (Arithmetic Logic\323 unit.  )S
-0.36 N (W)S
-0.961 N (ell, as the )S
141 367 M (name implies it can do logic as well.)S
123 385 M (2.)S
9 N (SAP-2 can do NO)S
-0.48 N (T)S
-0.891 N (, )S
-0.662 N (AND, OR, XOR, and the opcodes are CMA \(comple-)S
141 399 M (ment\),  )S
-0.662 N (AN)S
-0.422 N (A, ORA, and XRA respecti)S
-0.302 N (v)S
-0.182 N (ely)S
-0.782 N (.)S
123 417 M (3.)S
9 N (Each of these use re)S
-0.182 N (gister )S
-0.662 N (A as an inherent operand, and the other operand is )S
141 431 M (speci\336)S
(ed immediately as re)S
-0.182 N (gister B or C.)S
123 449 M (4.)S
9 N -0.217(The result is a bitwise logical operation. e)W
-0.182 N -0.217(g if )W
-0.662 N -0.217(A=00001111 and B=10101010 )W
141 463 M (then )S
-0.662 N (AN)S
-0.422 N (A B w)S
-0.12 N (ould result in )S
-0.662 N (A=00001010.)S
123 481 M (5.)S
9 N (There are immediate v)S
-0.182 N (ersions of these as well: )S
-0.662 N (ANI, ORI, XRI)S
123 499 M (6.)S
9 N (the corresponding HC11 instructions are COM, )S
-0.662 N (AND, ORA, EOR)S
FmE
137 0 :M
f201 sf
( )S
140 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 521 M (G.)S
14.666 N (Shifts and Rotates)S
FmE
140 0 :M
f148 sf
( )S
143 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 539 M (1.)S
9 N (SAP-2 has tw)S
-0.12 N (o instructions that do re)S
-0.182 N (gister rotate.)S
123 557 M (2.)S
9 N (Rotate is lik)S
-0.12 N (e a shift e)S
-0.182 N (xcept that the MSB is )S
141 571 M (transferred to the LSB for a left rotate, and )S
141 585 M (for a right rotate, the LSB is fed into the )S
141 599 M (MSB.)S
( )S
123 617 M (3.)S
9 N (SAP-2 instructions are RAL and RAR \(for )S
141 631 M (rotate )S
-0.662 N (A left and rotate )S
-0.662 N (A right)S
123 649 M (4.)S
9 N (HC11 has R)S
-0.48 N (OR and R)S
-0.48 N (OL \(usage, e)S
-0.182 N (g: )S
141 663 M (R)S
-0.48 N (ORA\), b)S
-0.24 N (ut the)S
-0.182 N (y\325)S
-0.601 N (re slightly dif)S
-0.302 N (ferent, as )S
141 677 M (we\325)S
-0.12 N (ll see.)S
FmE
352 549 158 115 rC
143 0 :M
FrMacBegin
352.032 549 157.968 114.024 FmKp
0 0 0 1 0 0 0 FmK
0 FmP
0.5 395 572 71 13 FmqP
FmE
143 0 :M
( )S
146 0 :M
FrMacBegin
352.032 549 157.968 114.024 FmKp
0 0 0 1 0 0 0 FmK
0 FmP
385 572 M (7)S
472 573 M (0)S
411 563 M (left rotate)S
477.535 578.5 FmB
-1.333 0 FmL
0 0.5 FmSo
476.202 578.5 FmB
1.083 2.976 FmL
-10.378 -2.976 FmL
10.378 -2.976 FmL
0.5 FmS
476.202 578.5 FmB
1.083 2.976 FmL
-10.378 -2.976 FmL
10.378 -2.976 FmL
FmFl
477.535 578.5 FmB
6.465 0 FmL
0 12.5 FmL
-109 0 FmL
0 -10.897 FmL
19 0 FmL
2 0.5 FmSo
416.535 580 FmB
-1.333 0 FmL
0 0.5 FmSo
415.202 580 FmB
1.083 2.976 FmL
-10.378 -2.976 FmL
10.378 -2.976 FmL
0.5 FmS
415.202 580 FmB
1.083 2.976 FmL
-10.378 -2.976 FmL
10.378 -2.976 FmL
FmFl
453 580 FmB
-36.465 0 FmL
2 0.5 FmSo
0.5 397 618 71 13 FmqP
387 618 M (7)S
474 619 M (0)S
413 609 M (right rotate)S
384.465 626.103 FmB
1.333 0 FmL
0 0.5 FmSo
385.798 626.103 FmB
-1.083 -2.976 FmL
10.378 2.976 FmL
-10.378 2.976 FmL
0.5 FmS
385.798 626.103 FmB
-1.083 -2.976 FmL
10.378 2.976 FmL
-10.378 2.976 FmL
FmFl
468 624.5 FmB
18 0 FmL
0 12.5 FmL
-109 0 FmL
0 -10.897 FmL
7.465 0 FmL
2 0.5 FmSo
443.465 626 FmB
1.333 0 FmL
0 0.5 FmSo
444.798 626 FmB
-1.083 -2.976 FmL
10.378 2.976 FmL
-10.378 2.976 FmL
0.5 FmS
444.798 626 FmB
-1.083 -2.976 FmL
10.378 2.976 FmL
-10.378 2.976 FmL
FmFl
443.465 626 FmB
-36.465 0 FmL
2 0.5 FmSo
FmE
endp
showpage
%%PageTrailer
%%Page: 6 6
%%BeginPageSetup
%RBIIncludePageSlotInvocation
mTSsetup
pmSVsetup
initializepage
(David Gerhard; page: 6 of 8)setjob
%%EndPageSetup
gS 0 0 552 728 rC
146 0 :M
FrMacBegin
0 FmP
0 FmSP
FmE
146 0 :M
f240 sf
( )S
149 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 13 M (the SAP-2)S
FmE
149 0 :M
f148 sf
( )S
152 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 725.022 M (P)S
-0.182 N (age )S
(6)S
( of )S
(8)S
FmE
152 0 :M
f201 sf
( )S
155 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 85 M (H.)S
14.666 N (Flo)S
-0.12 N (w of Contr)S
-0.217 N (ol Instructions)S
FmE
155 0 :M
f148 sf
( )S
158 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 103 M (1.)S
9 N (W)S
-0.961 N (e\325)S
-0.601 N (v)S
-0.182 N -0.371(e got a lot of functionality so f)W
-0.12 N (ar)S
-0.48 N -0.371(, b)W
-0.24 N -0.371(ut it\325)W
-0.662 N -0.371(s not v)W
-0.182 N -0.371(ery useful if we ha)W
-0.24 N (v)S
-0.182 N -0.371(e to go )W
141 117 M (from top to bottom)S
123 135 M (2.)S
9 N (W)S
-0.961 N (e w)S
-0.12 N (ant to be able to change what we do depending on what we ha)S
-0.24 N (v)S
-0.182 N (e just )S
141 149 M (done \(if-then constructions and loops!\))S
123 167 M (3.)S
9 N (Before we see ho)S
-0.302 N (w we do this, we need to talk about condition codes)S
141 185 M (a\))S
8.681 N (CONDITION CODES are single-bit v)S
-0.302 N (alues that record useful info about )S
159 199 M (the result of an )S
-0.662 N (ALU operation.)S
141 217 M (b\))S
8.007 N (In the SAP-2, these are the \337)S
(ags\(1:0\) that we sa)S
-0.182 N (w)S
-0.782 N (.)S
141 235 M (c\))S
8.681 N (One \337)S
(ag is set if the result of the )S
-0.662 N (ALU operation is zero \(the \324Z\325)S
-0.891 N ( \337)S
(ag\))S
141 253 M (d\))S
8.007 N (The other is set if the result of the operation is ne)S
-0.182 N (g)S
-0.062 N (ati)S
-0.302 N (v)S
-0.182 N (e \(the \324S\325)S
-0.891 N ( \337)S
(ag, for )S
159 267 M (sign\))S
141 285 M (e\))S
8.681 N (Only operations that use the )S
-0.662 N (ALU will af)S
-0.302 N (fect the condition codes.  )S
-0.217 N (These )S
159 299 M (are in table 11-3 as well.)S
159 317 M (\(1\))S
13.014 N (Usually)S
-0.782 N (, )S
-0.662 N (Arith or Logic operations af)S
-0.302 N (fect the control codes, while )S
186 331 M (data mo)S
-0.182 N (v)S
-0.182 N (ement instructions do not. )S
141 349 M (f\))S
10.014 N (HC11 has 8 condition code bits \(see section 6.1.5 on page 6-4 of the )S
159 363 M (manual\) and the analgous condition code bits are  Z for zero and N for )S
159 377 M (ne)S
-0.182 N (g)S
-0.062 N (ati)S
-0.302 N (v)S
-0.182 N (e. )S
141 395 M (g\))S
8.007 N -0.196(the HC11 has a C condition code for carry-out, and  )W
-0.601 N -0.196(V condition code for )W
159 409 M (o)S
-0.182 N (v)S
-0.182 N (er\337)S
(o)S
-0.302 N (w)S
-0.782 N (.  )S
-0.217 N (These are af)S
-0.302 N (fected by arithmetic operations b)S
-0.24 N (ut not by logic )S
159 423 M (operations.)S
123 441 M (4.)S
9 N (Condition codes are used in \337)S
(o)S
-0.302 N (w-of-control operations.)S
141 459 M (a\))S
8.681 N (in SAP-2, these are called jumps, and there are tw)S
-0.12 N (o types: Conditional )S
159 473 M (and unconditional.  )S
141 491 M (b\))S
8.007 N (The operand of the jump is the location in memory to jump to.)S
123 509 M (5.)S
9 N (Recall that for normal operation, an instruction fetch looks lik)S
-0.12 N (e this:)S
141 527 M (a\))S
8.681 N (The v)S
-0.302 N (alue in PC is used as the address of the instruction to fetch)S
141 545 M (b\))S
8.007 N (PC is incremented during the fetch, so it is ready to get the ne)S
-0.182 N (xt instruc-)S
159 559 M (tion)S
141 577 M (c\))S
8.681 N (The instruction fetched from PC is stored in ir)S
-0.662 N (.)S
123 595 M (6.)S
9 N (The important thing to notice is that the PC is already pointing at the ne)S
-0.182 N (xt )S
141 609 M (instruction when the current instruction be)S
-0.182 N (gins to e)S
-0.182 N (x)S
-0.182 N (ecute.)S
123 627 M (7.)S
9 N -0.152(If we w)W
-0.12 N -0.152(ant to fetch a dif)W
-0.302 N -0.152(ferent instruction, we need to change the v)W
-0.302 N -0.152(alue in the )W
141 641 M (pc.)S
123 659 M (8.)S
9 N (An unconditional jump loads a ne)S
-0.302 N (w v)S
-0.302 N (alue into the pc.)S
123 677 M (9.)S
9 N -0.288(A Conditional jump loads a ne)W
-0.302 N -0.288(w v)W
-0.302 N -0.288(alue into the pc only if the condition is met.)W
FmE
endp
showpage
%%PageTrailer
%%Page: 7 7
%%BeginPageSetup
%RBIIncludePageSlotInvocation
mTSsetup
pmSVsetup
initializepage
(David Gerhard; page: 7 of 8)setjob
%%EndPageSetup
gS 0 0 552 728 rC
158 0 :M
FrMacBegin
0 FmP
0 FmSP
FmE
158 0 :M
f240 sf
( )S
161 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
453.337 13 M (the SAP-2)S
FmE
161 0 :M
f148 sf
( )S
164 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
455.865 725.022 M (P)S
-0.182 N (age )S
(7)S
( of )S
(8)S
123 85 M (10.)S
3 N (The condition that may or may not be met depends on the result of the last )S
141 99 M (instruction e)S
-0.182 N (x)S
-0.182 N (ecuted.)S
141 117 M (a\))S
8.681 N (F)S
-0.182 N (or e)S
-0.182 N (xample, in the SAP-1, the jz instruction consults the \322zero\323 \337)S
(ag )S
159 131 M (\(from the )S
-0.662 N (ALU\) and will jump if the zero \337)S
(ag is 1.  If not, the ne)S
-0.182 N (xt )S
159 145 M (instruction in sequence is fetched)S
FmE
164 0 :M
f201 sf
( )S
167 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 167 M (I.)S
19.333 N (Example )S
-0.662 N (Assembly Code)S
FmE
167 0 :M
f148 sf
( )S
170 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 185 M (1.)S
9 N (Let\325)S
-0.662 N (s disco)S
-0.182 N (v)S
-0.182 N (er what assembly language w)S
-0.12 N (ould be generated from this \322High-)S
141 199 M (le)S
-0.302 N (v)S
-0.182 N (el language\323 se)S
-0.182 N (gment \(in pseudo-C\) [o)S
-0.182 N (v)S
-0.182 N (erhead])S
159 217 M (if\(widget_cnt > 0\))S
159 235 M ({ got_widgets = 1;})S
159 253 M (else)S
159 271 M ({got_widgets = 0; })S
123 289 M (2.)S
9 N (Ho)S
-0.302 N (w w)S
-0.12 N (ould this look in SAP-2?)S
141 307 M (a\))S
8.681 N (W)S
-0.961 N (e need memory storage locations for \322widget_cnt\323 and \322got_widgets\323, )S
159 321 M (so let\325)S
-0.662 N (s assume we\325)S
-0.601 N (v)S
-0.182 N (e allocated a couple of bytes, say 2ah and 2bh.)S
141 339 M (b\))S
8.007 N (W)S
-0.961 N (e need to \336)S
(gure out what needs to be done.)S
159 357 M (\(1\))S
13.014 N (Load \322widget_cnt\323 into a re)S
-0.182 N (gister)S
159 375 M (\(2\))S
13.014 N (test if it\325)S
-0.662 N (s greater than zero)S
159 393 M (\(3\))S
13.014 N (use jump commands to go to teh appropriate chunk of code)S
159 411 M (\(4\))S
13.014 N (place a 1 or a 0 in got_widgets, whiche)S
-0.302 N (v)S
-0.182 N (er is appropriate.)S
123 429 M (3.)S
9 N (we can use lda to load the v)S
-0.302 N (alue into the )S
-0.662 N (A re)S
-0.182 N (gister)S
-0.662 N (.)S
123 447 M (4.)S
9 N (W)S
-0.961 N (e need an instruction that will gi)S
-0.302 N (v)S
-0.182 N (e )S
-0.662 N (A at the )S
-0.662 N (ALU without changing )S
-0.662 N (A.  )S
123 465 M (5.)S
9 N -0.012(Lots of instructions af)W
-0.302 N -0.012(fect the condition codes \(see o)W
-0.182 N (v)S
-0.182 N -0.012(erhead\) b)W
-0.24 N -0.012(ut we w)W
-0.12 N -0.012(ant to )W
141 479 M (use one that has the correct result with the least side-ef)S
-0.302 N (fects.)S
141 497 M (a\))S
8.681 N (add, sub, anda, ora, xra all require something to be in B or C)S
141 515 M (b\))S
8.007 N (ani, ori, xri will w)S
-0.12 N (ork well because the)S
-0.182 N (y use immediate addressing.)S
141 533 M (c\))S
8.681 N (let\325)S
-0.662 N (s use ori 00h. )S
123 551 M (6.)S
9 N (Here\325)S
-0.662 N (s the assembly language fragment \(o)S
-0.182 N (v)S
-0.182 N (erhead\))S
141 569 M (a\))S
8.681 N (or)S
-0.217 N (g is a \322pseudo-op\323 to tell the assembler to start putting instructions or )S
159 583 M (data in a speci\336)S
(c place in memory)S
-0.782 N (.)S
141 601 M (b\))S
8.007 N (W)S
-0.48 N -0.137(ith this command, we needn\325)W
-0.217 N -0.137(t write our assembly language program in )W
159 615 M (order)S
-0.48 N (, as long as we k)S
-0.12 N (eep our or)S
-0.217 N (gs straight.)S
141 633 M (c\))S
8.681 N (b)S
-0.24 N -0.339(ut the assembler will o)W
-0.182 N (v)S
-0.182 N -0.339(erwrite pre)W
-0.302 N -0.339(vious or)W
-0.217 N (g\325)S
-0.662 N -0.339(s if we tell it to, so we gotta )W
159 647 M (be careful.)S
123 665 M (7.)S
9 N (the \322lda\323 and \322ora\323 instructions get the v)S
-0.302 N (alue of \322widget_cnt\323 as we ha)S
-0.24 N (v)S
-0.182 N (e )S
141 679 M (already seen.)S
FmE
endp
showpage
%%PageTrailer
%%Page: 8 8
%%BeginPageSetup
%RBIIncludePageSlotInvocation
mTSsetup
pmSVsetup
initializepage
(David Gerhard; page: 8 of 8)setjob
%%EndPageSetup
gS 0 0 552 728 rC
170 0 :M
FrMacBegin
0 FmP
0 FmSP
FmE
170 0 :M
f240 sf
( )S
173 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 13 M (the SAP-2)S
FmE
173 0 :M
f148 sf
( )S
176 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
42 725.022 M (P)S
-0.182 N (age )S
(8)S
( of )S
(8)S
123 85 M (8.)S
9 N 0(Then we w)W
-0.12 N 0(ant to do one of tw)W
-0.12 N 0(o things depending on the v)W
-0.302 N 0(alue of the \322z\323 and )W
141 99 M (\322s\323 \337)S
(ags.)S
123 117 M (9.)S
9 N (First, if \322z\323 is true, we jump to \322no widgets\323. )S
123 135 M (10.)S
3 N (Then, if \322s\323 is true, we also jump to \322no widgets\323 \(jm=jump if minus\))S
123 153 M (11.)S
3 N (These tw)S
-0.12 N (o together skip to the \322else\323 clause if widget_cnt )S
FmE
176 0 :M
f287 sf
( )S
178 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
420.765 153 M (\243)S
FmE
179 0 :M
f300 sf
( )S
181 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
426.802 153 M ( 0.)S
FmE
182 0 :M
f148 sf
( )S
185 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 171 M (12.)S
3 N (If neither s nor z are true, the ne)S
-0.182 N (xt instructions \(\322widgets\323\) are e)S
-0.182 N (x)S
-0.182 N (ecuted.)S
141 189 M (a\))S
8.681 N (b)S
-0.24 N (ut then we need to skip o)S
-0.182 N (v)S
-0.182 N (er the \322else\323 clause, so we jmp to set_v)S
-0.302 N (alue, )S
159 203 M (which is where e)S
-0.182 N (x)S
-0.182 N (ecution continues after both the if clause and the else )S
159 217 M (clause: we store the )S
-0.662 N (A v)S
-0.302 N (alue back into memory)S
-0.782 N (.)S
123 235 M (13.)S
3 N -0.125(Note that we could do this the other w)W
-0.12 N -0.125(ay: ha)W
-0.24 N (v)S
-0.182 N -0.125(e the else clause \336)W
-0.125(rst, and jump )W
141 249 M (o)S
-0.182 N (v)S
-0.182 N (er it if widget_cnt > 0.)S
FmE
185 0 :M
f201 sf
( )S
188 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
96 271 M (J)S
-0.24 N (.)S
18.24 N (Example listing \336)S
(le)S
FmE
188 0 :M
f148 sf
( )S
191 0 :M
FrMacBegin
0 0 0 1 0 0 0 FmK
0 FmP
123 289 M (1.)S
9 N (If we were to assemble that code, we\325)S
-0.601 N (d get this listing \336)S
(le \(o)S
-0.182 N (v)S
-0.182 N (erhead\))S
123 307 M (2.)S
9 N (Leftmost column sho)S
-0.302 N (ws memory address in he)S
-0.182 N (x)S
123 325 M (3.)S
9 N (ne)S
-0.182 N (xt column sho)S
-0.302 N (ws memory contents, in he)S
-0.182 N (x.)S
123 343 M (4.)S
9 N (During assembly)S
-0.782 N (, the assembler resolv)S
-0.182 N (es labels to memory addresses, and )S
141 357 M (uses them in other instructions as necessary)S
-0.782 N (.)S
141 375 M (a\))S
8.681 N (e)S
-0.182 N (g, for jz no_widgets)S
141 393 M (b\))S
8.007 N (This instruction is in memory 0005h to 0007h.  )S
141 411 M (c\))S
8.681 N (The opcode is cah, stored in memory 0005h.)S
141 429 M (d\))S
8.007 N (the tar)S
-0.217 N (get of the jump \(the operand\) is the mvi instruction, located in )S
159 443 M (memory location 0010h, so that address is placed in memory 0006h and )S
159 457 M (0007h, LSbyte \336)S
(rst as is the con)S
-0.48 N (v)S
-0.182 N (ention for SAP-2.)S
123 475 M (5.)S
9 N -0.254(Another e)W
-0.182 N -0.254(xample: mvi is an immediate instruction, which mo)W
-0.182 N (v)S
-0.182 N -0.254(es the v)W
-0.302 N -0.254(alue in )W
141 489 M (\322)S
-0.961 N (A\323 to the indicated memory)S
-0.782 N (.  )S
-0.217 N (The assembly language said put it in )S
141 503 M (\322got_widgets\323, b)S
-0.24 N (ut the assembler kne)S
-0.302 N (w that this corresponds to memory )S
141 517 M (location 2bh.)S
FmE
endp
showpage
%%PageTrailer
%%Trailer
end
%%EOF
